
AVRASM ver. 2.1.30  D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm Wed Jan 06 20:26:32 2016

D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1104): warning: Register r2 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1105): warning: Register r3 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1106): warning: Register r5 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1107): warning: Register r4 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1108): warning: Register r6 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1109): warning: Register r7 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1110): warning: Register r8 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1111): warning: Register r9 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1112): warning: Register r10 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1113): warning: Register r11 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1114): warning: Register r12 already defined by the .DEF directive
D:\Najari\fanavaran sharif\projects\ADIO\code\GPIO\Debug\List\test.asm(1115): warning: Register r13 already defined by the .DEF directive
                 
                 
                 ;CodeVisionAVR C Compiler V3.12 Advanced
                 ;(C) Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Build configuration    : Debug
                 ;Chip type              : ATxmega64A3U
                 ;Program type           : Application
                 ;Clock frequency        : 32.000000 MHz
                 ;Memory model           : Small
                 ;Optimize for           : Size
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External RAM size      : 0
                 ;Data Stack size        : 1024 byte(s)
                 ;Heap size              : 0 byte(s)
                 ;Promote 'char' to 'int': Yes
                 ;'char' is unsigned     : Yes
                 ;8 bit enums            : Yes
                 ;Global 'const' stored in FLASH: Yes
                 ;Enhanced function parameter passing: Yes
                 ;Enhanced core instructions: On
                 ;Automatic register allocation for global variables: On
                 ;Smart register allocation: On
                 
                 	#define _MODEL_SMALL_
                 
                 	#pragma AVRPART ADMIN PART_NAME ATxmega64A3U
                 	#pragma AVRPART MEMORY PROG_FLASH 69632
                 	#pragma AVRPART MEMORY EEPROM 2048
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x2000
                 
                 	#define CALL_SUPPORTED 1
                 
                 	.LISTMAC
                 	.EQU CCP=0x34
                 	.EQU RAMPD=0x38
                 	.EQU RAMPX=0x39
                 	.EQU RAMPY=0x3A
                 	.EQU RAMPZ=0x3B
                 	.EQU EIND=0x3C
                 	.EQU WDT_CTRL=0x80
                 	.EQU PMIC_CTRL=0xA2
                 	.EQU NVM_ADDR0=0X01C0
                 	.EQU NVM_ADDR1=NVM_ADDR0+1
                 	.EQU NVM_ADDR2=NVM_ADDR1+1
                 	.EQU NVM_DATA0=NVM_ADDR0+4
                 	.EQU NVM_CMD=NVM_ADDR0+0xA
                 	.EQU NVM_CTRLA=NVM_ADDR0+0xB
                 	.EQU NVM_CTRLB=NVM_ADDR0+0xC
                 	.EQU NVM_STATUS=NVM_ADDR0+0xF
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU GPIO0=0x00
                 	.EQU GPIO1=0x01
                 	.EQU GPIO2=0x02
                 	.EQU GPIO3=0x03
                 	.EQU GPIO4=0x04
                 	.EQU GPIO5=0x05
                 	.EQU GPIO6=0x06
                 	.EQU GPIO7=0x07
                 	.EQU GPIO8=0x08
                 	.EQU GPIO9=0x09
                 	.EQU GPIO10=0x0A
                 	.EQU GPIO11=0x0B
                 	.EQU GPIO12=0x0C
                 	.EQU GPIO13=0x0D
                 	.EQU GPIO14=0x0E
                 	.EQU GPIO15=0x0F
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __SRAM_START=0x2000
                 	.EQU __SRAM_END=0x2FFF
                 	.EQU __DSTACK_SIZE=0x0400
                 	.EQU __HEAP_SIZE=0x0000
                 	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDBMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ANDWMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ANDI R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD2N
                 	ANDI R26,LOW(@0)
                 	ANDI R27,HIGH(@0)
                 	ANDI R24,BYTE3(@0)
                 	ANDI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORBMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ORWMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ORI  R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD2N
                 	ORI  R26,LOW(@0)
                 	ORI  R27,HIGH(@0)
                 	ORI  R24,BYTE3(@0)
                 	ORI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+(@1))
                 	LDI  R31,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1M
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	LDI  R22,BYTE3(2*@0+(@1))
                 	LDI  R23,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	LDI  R24,BYTE3(2*@0+(@1))
                 	LDI  R25,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+(@2))
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+(@3))
                 	LDI  R@1,HIGH(@2+(@3))
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+(@3))
                 	LDI  R@1,HIGH(@2*2+(@3))
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	LDS  R22,@0+(@1)+2
                 	LDS  R23,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+(@2)
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+(@3)
                 	LDS  R@1,@2+(@3)+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	LDS  R24,@0+(@1)+2
                 	LDS  R25,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	STS  @0+(@1)+2,R22
                 	STS  @0+(@1)+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTB1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRB
                 	.ENDM
                 
                 	.MACRO __PUTW1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRW
                 	.ENDM
                 
                 	.MACRO __PUTD1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRD
                 	.ENDM
                 
                 	.MACRO __PUTBR0MN
                 	STS  @0+(@1),R0
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+(@1),R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+(@1),R@2
                 	STS  @0+(@1)+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTBSR
                 	STD  Y+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	PUSH R26
                 	PUSH R27
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMRDW
                 	POP  R27
                 	POP  R26
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EX
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	CALL __EEPROMRDD
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __GETBRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	LD   R@0,X
                 	.ENDM
                 
                 	.MACRO __GETWRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	LD   R@0,X+
                 	LD   R@1,X
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	ST   Z,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRR0
                 	MULS R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBRRU0
                 	MUL  R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBNWRU
                 	LDI  R26,@2
                 	MUL  R26,R@0
                 	MOVW R30,R0
                 	MUL  R26,R@1
                 	ADD  R31,R0
                 	.ENDM
                 
                 ;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
                 	.DEF _DAQ_data=R2
                 	.DEF _DAQ_data_msb=R3
                 	.DEF _start_byte=R5
                 	.DEF _stop_byte=R4
                 	.DEF _flag=R6
                 	.DEF _flag_msb=R7
                 	.DEF _data_recieved=R8
                 	.DEF _data_recieved_msb=R9
                 	.DEF _packet_start=R10
                 	.DEF _packet_start_msb=R11
                 	.DEF _DAC_data=R12
                 	.DEF _DAC_data_msb=R13
                 
                 ;GPIO0-GPIO15 INITIALIZATION VALUES
                 	.EQU __GPIO0_INIT=0x00
                 	.EQU __GPIO1_INIT=0x00
                 	.EQU __GPIO2_INIT=0x00
                 	.EQU __GPIO3_INIT=0x00
                 	.EQU __GPIO4_INIT=0x00
                 	.EQU __GPIO5_INIT=0x00
                 	.EQU __GPIO6_INIT=0x00
                 	.EQU __GPIO7_INIT=0x00
                 	.EQU __GPIO8_INIT=0x00
                 	.EQU __GPIO9_INIT=0x00
                 	.EQU __GPIO10_INIT=0x00
                 	.EQU __GPIO11_INIT=0x00
                 	.EQU __GPIO12_INIT=0x00
                 	.EQU __GPIO13_INIT=0x00
                 	.EQU __GPIO14_INIT=0x00
                 	.EQU __GPIO15_INIT=0x00
                 
                 ;GLOBAL REGISTER VARIABLES INITIALIZATION VALUES
                 	.EQU __R2_INIT=0x00
                 	.EQU __R3_INIT=0x00
                 	.EQU __R4_INIT=0xBB
                 	.EQU __R5_INIT=0xAA
                 	.EQU __R6_INIT=0x00
                 	.EQU __R7_INIT=0x00
                 	.EQU __R8_INIT=0x00
                 	.EQU __R9_INIT=0x00
                 	.EQU __R10_INIT=0x00
                 	.EQU __R11_INIT=0x00
                 	.EQU __R12_INIT=0x00
                 	.EQU __R13_INIT=0x00
                 	.EQU __R14_INIT=0x00
                 
                 	.CSEG
                 	.ORG 0x00
                 
                 ;START OF CODE MARKER
                 __START_OF_CODE:
                 
                 ;INTERRUPT VECTORS
000000 940c 0107 	JMP  __RESET
000002 940c 0000 	JMP  0x00
000004 940c 0000 	JMP  0x00
000006 940c 0000 	JMP  0x00
000008 940c 0000 	JMP  0x00
00000a 940c 0000 	JMP  0x00
00000c 940c 0000 	JMP  0x00
00000e 940c 0000 	JMP  0x00
000010 940c 0000 	JMP  0x00
000012 940c 0000 	JMP  0x00
000014 940c 0000 	JMP  0x00
000016 940c 0000 	JMP  0x00
000018 940c 0000 	JMP  0x00
00001a 940c 0000 	JMP  0x00
00001c 940c 0000 	JMP  0x00
00001e 940c 0000 	JMP  0x00
000020 940c 0000 	JMP  0x00
000022 940c 0000 	JMP  0x00
000024 940c 0000 	JMP  0x00
000026 940c 0000 	JMP  0x00
000028 940c 0000 	JMP  0x00
00002a 940c 0000 	JMP  0x00
00002c 940c 0000 	JMP  0x00
00002e 940c 0000 	JMP  0x00
000030 940c 0000 	JMP  0x00
000032 940c 0000 	JMP  0x00
000034 940c 0000 	JMP  0x00
000036 940c 0000 	JMP  0x00
000038 940c 0000 	JMP  0x00
00003a 940c 0000 	JMP  0x00
00003c 940c 0000 	JMP  0x00
00003e 940c 0000 	JMP  0x00
000040 940c 0000 	JMP  0x00
000042 940c 0000 	JMP  0x00
000044 940c 0000 	JMP  0x00
000046 940c 0000 	JMP  0x00
000048 940c 0000 	JMP  0x00
00004a 940c 0000 	JMP  0x00
00004c 940c 0000 	JMP  0x00
00004e 940c 0000 	JMP  0x00
000050 940c 0000 	JMP  0x00
000052 940c 0000 	JMP  0x00
000054 940c 0000 	JMP  0x00
000056 940c 0000 	JMP  0x00
000058 940c 0000 	JMP  0x00
00005a 940c 0000 	JMP  0x00
00005c 940c 0000 	JMP  0x00
00005e 940c 0000 	JMP  0x00
000060 940c 0000 	JMP  0x00
000062 940c 0000 	JMP  0x00
000064 940c 0000 	JMP  0x00
000066 940c 0000 	JMP  0x00
000068 940c 0000 	JMP  0x00
00006a 940c 0000 	JMP  0x00
00006c 940c 0000 	JMP  0x00
00006e 940c 0000 	JMP  0x00
000070 940c 0000 	JMP  0x00
000072 940c 0000 	JMP  0x00
000074 940c 0000 	JMP  0x00
000076 940c 0000 	JMP  0x00
000078 940c 0000 	JMP  0x00
00007a 940c 0000 	JMP  0x00
00007c 940c 0000 	JMP  0x00
00007e 940c 0000 	JMP  0x00
000080 940c 0000 	JMP  0x00
000082 940c 0000 	JMP  0x00
000084 940c 0000 	JMP  0x00
000086 940c 0000 	JMP  0x00
000088 940c 0000 	JMP  0x00
00008a 940c 0000 	JMP  0x00
00008c 940c 0000 	JMP  0x00
00008e 940c 0000 	JMP  0x00
000090 940c 0000 	JMP  0x00
000092 940c 0000 	JMP  0x00
000094 940c 0000 	JMP  0x00
000096 940c 0000 	JMP  0x00
000098 940c 0000 	JMP  0x00
00009a 940c 0000 	JMP  0x00
00009c 940c 0000 	JMP  0x00
00009e 940c 0000 	JMP  0x00
0000a0 940c 0000 	JMP  0x00
0000a2 940c 0000 	JMP  0x00
0000a4 940c 0000 	JMP  0x00
0000a6 940c 0000 	JMP  0x00
0000a8 940c 0000 	JMP  0x00
0000aa 940c 0000 	JMP  0x00
0000ac 940c 0000 	JMP  0x00
0000ae 940c 0000 	JMP  0x00
0000b0 940c 0000 	JMP  0x00
0000b2 940c 0000 	JMP  0x00
0000b4 940c 0000 	JMP  0x00
0000b6 940c 0000 	JMP  0x00
0000b8 940c 0000 	JMP  0x00
0000ba 940c 0000 	JMP  0x00
0000bc 940c 0000 	JMP  0x00
0000be 940c 0000 	JMP  0x00
0000c0 940c 0000 	JMP  0x00
0000c2 940c 0000 	JMP  0x00
0000c4 940c 0000 	JMP  0x00
0000c6 940c 0000 	JMP  0x00
0000c8 940c 0000 	JMP  0x00
0000ca 940c 0000 	JMP  0x00
0000cc 940c 0000 	JMP  0x00
0000ce 940c 0000 	JMP  0x00
0000d0 940c 0000 	JMP  0x00
0000d2 940c 0000 	JMP  0x00
0000d4 940c 0000 	JMP  0x00
0000d6 940c 0000 	JMP  0x00
0000d8 940c 0000 	JMP  0x00
0000da 940c 0000 	JMP  0x00
0000dc 940c 0000 	JMP  0x00
0000de 940c 0000 	JMP  0x00
0000e0 940c 0000 	JMP  0x00
0000e2 940c 0000 	JMP  0x00
0000e4 940c 0000 	JMP  0x00
0000e6 940c 0000 	JMP  0x00
0000e8 940c 0000 	JMP  0x00
0000ea 940c 0000 	JMP  0x00
0000ec 940c 0000 	JMP  0x00
0000ee 940c 0299 	JMP  _usartf0_rx_isr
0000f0 940c 0000 	JMP  0x00
0000f2 940c 02e1 	JMP  _usartf0_tx_isr
0000f4 940c 0000 	JMP  0x00
0000f6 940c 0000 	JMP  0x00
0000f8 940c 0000 	JMP  0x00
0000fa 940c 0000 	JMP  0x00
0000fc 940c 0000 	JMP  0x00
                 
                 _tbl10_G100:
0000fe 2710
0000ff 03e8
000100 0064
000101 000a      	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
000102 0001      	.DB  0x1,0x0
                 _tbl16_G100:
000103 1000
000104 0100
000105 0010
000106 0001      	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0
                 
                 __RESET:
000107 94f8      	CLI
000108 27ee      	CLR  R30
                 
                 ;MEMORY MAPPED EEPROM ACCESS IS USED
000109 91f0 01cc 	LDS  R31,NVM_CTRLB
00010b 60f8      	ORI  R31,0x08
00010c 93f0 01cc 	STS  NVM_CTRLB,R31
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF FLASH
00010e edf8      	LDI  R31,0xD8
00010f bff4      	OUT  CCP,R31
000110 93e0 00a2 	STS  PMIC_CTRL,R30
                 
                 ;CLEAR SRAM
000112 e080      	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
000113 e190      	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
000114 e0a0      	LDI  R26,LOW(__SRAM_START)
000115 e2b0      	LDI  R27,HIGH(__SRAM_START)
                 __CLEAR_SRAM:
000116 93ed      	ST   X+,R30
000117 9701      	SBIW R24,1
000118 f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GPIO0-GPIO15 INITIALIZATION
000119 e0e0      	LDI  R30,__GPIO0_INIT
00011a b9e0      	OUT  GPIO0,R30
                 	;__GPIO1_INIT = __GPIO0_INIT
00011b b9e1      	OUT  GPIO1,R30
                 	;__GPIO2_INIT = __GPIO0_INIT
00011c b9e2      	OUT  GPIO2,R30
                 	;__GPIO3_INIT = __GPIO0_INIT
00011d b9e3      	OUT  GPIO3,R30
                 	;__GPIO4_INIT = __GPIO0_INIT
00011e b9e4      	OUT  GPIO4,R30
                 	;__GPIO5_INIT = __GPIO0_INIT
00011f b9e5      	OUT  GPIO5,R30
                 	;__GPIO6_INIT = __GPIO0_INIT
000120 b9e6      	OUT  GPIO6,R30
                 	;__GPIO7_INIT = __GPIO0_INIT
000121 b9e7      	OUT  GPIO7,R30
                 	;__GPIO8_INIT = __GPIO0_INIT
000122 b9e8      	OUT  GPIO8,R30
                 	;__GPIO9_INIT = __GPIO0_INIT
000123 b9e9      	OUT  GPIO9,R30
                 	;__GPIO10_INIT = __GPIO0_INIT
000124 b9ea      	OUT  GPIO10,R30
                 	;__GPIO11_INIT = __GPIO0_INIT
000125 b9eb      	OUT  GPIO11,R30
                 	;__GPIO12_INIT = __GPIO0_INIT
000126 b9ec      	OUT  GPIO12,R30
                 	;__GPIO13_INIT = __GPIO0_INIT
000127 b9ed      	OUT  GPIO13,R30
                 	;__GPIO14_INIT = __GPIO0_INIT
000128 b9ee      	OUT  GPIO14,R30
                 	;__GPIO15_INIT = __GPIO0_INIT
000129 b9ef      	OUT  GPIO15,R30
                 
                 ;GLOBAL REGISTER VARIABLES INITIALIZATION
00012a ebeb      	LDI  R30,__R4_INIT
00012b 2e4e      	MOV  R4,R30
00012c eaea      	LDI  R30,__R5_INIT
00012d 2e5e      	MOV  R5,R30
00012e e0e0      	LDI  R30,__R6_INIT
00012f 2e6e      	MOV  R6,R30
                 	;__R7_INIT = __R6_INIT
000130 2e7e      	MOV  R7,R30
                 	;__R8_INIT = __R6_INIT
000131 2e8e      	MOV  R8,R30
                 	;__R9_INIT = __R6_INIT
000132 2e9e      	MOV  R9,R30
                 	;__R10_INIT = __R6_INIT
000133 2eae      	MOV  R10,R30
                 	;__R11_INIT = __R6_INIT
000134 2ebe      	MOV  R11,R30
                 	;__R12_INIT = __R6_INIT
000135 2ece      	MOV  R12,R30
                 	;__R13_INIT = __R6_INIT
000136 2ede      	MOV  R13,R30
                 
                 ;HARDWARE STACK POINTER INITIALIZATION
000137 efef      	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
000138 bfed      	OUT  SPL,R30
000139 e2ef      	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
00013a bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
00013b e0c0      	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
00013c e2d4      	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)
                 
00013d 940c 0485 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x2400
                 
                 	.CSEG
                 ;// I/O Registers definitions
                 ;#include <io.h>
                 ;#include <delay.h>
                 ;
                 ;// Standard Input/Output functions
                 ;#include <stdio.h>
                 ;unsigned int DAQ_data = 0;
                 ;float f_DAQ_data = 0;
                 ;unsigned char start_byte=0xAA;
                 ;unsigned char stop_byte=0xBB;
                 ; int flag;
                 ;char requ_buffer[14];
                 ;#define packet_size_request     12
                 ;unsigned int data_recieved;
                 ;unsigned int packet_start;
                 ;unsigned int DAC_data;
                 ;
                 ;// Declare your global variables here
                 ;void dacb_write(unsigned char ch, unsigned int data);
                 ;// System Clocks initialization
                 ;void system_clocks_init(void)
                 ; 0000 0016 {
                 
                 	.CSEG
                 _system_clocks_init:
                 ; .FSTART _system_clocks_init
                 ; 0000 0017 unsigned char n,s;
                 ; 0000 0018 
                 ; 0000 0019 // Optimize for speed
                 ; 0000 001A #pragma optsize-
                 ; 0000 001B // Save interrupts enabled/disabled state
                 ; 0000 001C s=SREG;
00013f 931a      	ST   -Y,R17
000140 930a      	ST   -Y,R16
                 ;	n -> R17
                 ;	s -> R16
000141 b70f      	IN   R16,63
                 ; 0000 001D // Disable interrupts
                 ; 0000 001E #asm("cli")
000142 94f8      	cli
                 ; 0000 001F 
                 ; 0000 0020 // Internal 32 MHz RC oscillator initialization
                 ; 0000 0021 // Enable the internal 32 MHz RC oscillator
                 ; 0000 0022 OSC.CTRL|=OSC_RC32MEN_bm;
000143 91e0 0050 	LDS  R30,80
000145 60e2      	ORI  R30,2
000146 93e0 0050 	STS  80,R30
                 ; 0000 0023 
                 ; 0000 0024 // System Clock prescaler A division factor: 1
                 ; 0000 0025 // System Clock prescalers B & C division factors: B:1, C:1
                 ; 0000 0026 // ClkPer4: 32000.000 kHz
                 ; 0000 0027 // ClkPer2: 32000.000 kHz
                 ; 0000 0028 // ClkPer:  32000.000 kHz
                 ; 0000 0029 // ClkCPU:  32000.000 kHz
                 ; 0000 002A n=(CLK.PSCTRL & (~(CLK_PSADIV_gm | CLK_PSBCDIV1_bm | CLK_PSBCDIV0_bm))) |
                 ; 0000 002B 	CLK_PSADIV_1_gc | CLK_PSBCDIV_1_1_gc;
000148 91e0 0041 	LDS  R30,65
00014a 78e0      	ANDI R30,LOW(0x80)
00014b 2f1e      	MOV  R17,R30
                 ; 0000 002C CCP=CCP_IOREG_gc;
00014c ede8      	LDI  R30,LOW(216)
00014d bfe4      	OUT  0x34,R30
                 ; 0000 002D CLK.PSCTRL=n;
00014e 9310 0041 	STS  65,R17
                 ; 0000 002E 
                 ; 0000 002F // Disable the auto-calibration of the internal 32 MHz RC oscillator
                 ; 0000 0030 DFLLRC32M.CTRL&= ~DFLL_ENABLE_bm;
000150 91e0 0060 	LDS  R30,96
000152 7fee      	ANDI R30,0xFE
000153 93e0 0060 	STS  96,R30
                 ; 0000 0031 
                 ; 0000 0032 // Wait for the internal 32 MHz RC oscillator to stabilize
                 ; 0000 0033 while ((OSC.STATUS & OSC_RC32MRDY_bm)==0);
                 _0x3:
000155 91e0 0051 	LDS  R30,81
000157 70e2      	ANDI R30,LOW(0x2)
000158 f3e1      	BREQ _0x3
                 ; 0000 0034 
                 ; 0000 0035 // Select the system clock source: 32 MHz Internal RC Osc.
                 ; 0000 0036 n=(CLK.CTRL & (~CLK_SCLKSEL_gm)) | CLK_SCLKSEL_RC32M_gc;
000159 91e0 0040 	LDS  R30,64
00015b 7fe8      	ANDI R30,LOW(0xF8)
00015c 60e1      	ORI  R30,1
00015d 2f1e      	MOV  R17,R30
                 ; 0000 0037 CCP=CCP_IOREG_gc;
00015e ede8      	LDI  R30,LOW(216)
00015f bfe4      	OUT  0x34,R30
                 ; 0000 0038 CLK.CTRL=n;
000160 9310 0040 	STS  64,R17
                 ; 0000 0039 
                 ; 0000 003A // Disable the unused oscillators: 2 MHz, internal 32 kHz, external clock/crystal oscillator, PLL
                 ; 0000 003B OSC.CTRL&= ~(OSC_RC2MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
000162 91e0 0050 	LDS  R30,80
000164 7ee2      	ANDI R30,LOW(0xE2)
000165 93e0 0050 	STS  80,R30
                 ; 0000 003C 
                 ; 0000 003D // ClkPer output disabled
                 ; 0000 003E PORTCFG.CLKEVOUT&= ~(PORTCFG_CLKOUTSEL_gm | PORTCFG_CLKOUT_gm);
000167 91e0 00b4 	LDS  R30,180
000169 7fe0      	ANDI R30,LOW(0xF0)
00016a 93e0 00b4 	STS  180,R30
                 ; 0000 003F // Restore interrupts enabled/disabled state
                 ; 0000 0040 SREG=s;
00016c bf0f      	OUT  0x3F,R16
                 ; 0000 0041 // Restore optimization for size if needed
                 ; 0000 0042 #pragma optsize_default
                 ; 0000 0043 }
00016d c261      	RJMP _0x2060004
                 ; .FEND
                 ;
                 ;// Event System initialization
                 ;void event_system_init(void)
                 ; 0000 0047 {
                 _event_system_init:
                 ; .FSTART _event_system_init
                 ; 0000 0048 // Event System Channel 0 source: None
                 ; 0000 0049 EVSYS.CH0MUX=EVSYS_CHMUX_OFF_gc;
00016e e0e0      	LDI  R30,LOW(0)
00016f 93e0 0180 	STS  384,R30
                 ; 0000 004A // Event System Channel 1 source: None
                 ; 0000 004B EVSYS.CH1MUX=EVSYS_CHMUX_OFF_gc;
000171 93e0 0181 	STS  385,R30
                 ; 0000 004C // Event System Channel 2 source: None
                 ; 0000 004D EVSYS.CH2MUX=EVSYS_CHMUX_OFF_gc;
000173 93e0 0182 	STS  386,R30
                 ; 0000 004E // Event System Channel 3 source: None
                 ; 0000 004F EVSYS.CH3MUX=EVSYS_CHMUX_OFF_gc;
000175 93e0 0183 	STS  387,R30
                 ; 0000 0050 // Event System Channel 4 source: None
                 ; 0000 0051 EVSYS.CH4MUX=EVSYS_CHMUX_OFF_gc;
000177 93e0 0184 	STS  388,R30
                 ; 0000 0052 // Event System Channel 5 source: None
                 ; 0000 0053 EVSYS.CH5MUX=EVSYS_CHMUX_OFF_gc;
000179 93e0 0185 	STS  389,R30
                 ; 0000 0054 // Event System Channel 6 source: None
                 ; 0000 0055 EVSYS.CH6MUX=EVSYS_CHMUX_OFF_gc;
00017b 93e0 0186 	STS  390,R30
                 ; 0000 0056 // Event System Channel 7 source: None
                 ; 0000 0057 EVSYS.CH7MUX=EVSYS_CHMUX_OFF_gc;
00017d 93e0 0187 	STS  391,R30
                 ; 0000 0058 
                 ; 0000 0059 // Event System Channel 0 Digital Filter Coefficient: 1 Sample
                 ; 0000 005A // Quadrature Decoder: Off
                 ; 0000 005B EVSYS.CH0CTRL=(EVSYS.CH0CTRL & (~(EVSYS_QDIRM_gm | EVSYS_QDIEN_bm | EVSYS_QDEN_bm | EVSYS_DIGFILT_gm))) |
                 ; 0000 005C 	EVSYS_DIGFILT_1SAMPLE_gc;
00017f 91e0 0188 	LDS  R30,392
000181 78e0      	ANDI R30,LOW(0x80)
000182 93e0 0188 	STS  392,R30
                 ; 0000 005D // Event System Channel 1 Digital Filter Coefficient: 1 Sample
                 ; 0000 005E EVSYS.CH1CTRL=EVSYS_DIGFILT_1SAMPLE_gc;
000184 e0e0      	LDI  R30,LOW(0)
000185 93e0 0189 	STS  393,R30
                 ; 0000 005F // Event System Channel 2 Digital Filter Coefficient: 1 Sample
                 ; 0000 0060 // Quadrature Decoder: Off
                 ; 0000 0061 EVSYS.CH2CTRL=(EVSYS.CH2CTRL & (~(EVSYS_QDIRM_gm | EVSYS_QDIEN_bm | EVSYS_QDEN_bm | EVSYS_DIGFILT_gm))) |
                 ; 0000 0062 	EVSYS_DIGFILT_1SAMPLE_gc;
000187 91e0 018a 	LDS  R30,394
000189 78e0      	ANDI R30,LOW(0x80)
00018a 93e0 018a 	STS  394,R30
                 ; 0000 0063 // Event System Channel 3 Digital Filter Coefficient: 1 Sample
                 ; 0000 0064 EVSYS.CH3CTRL=EVSYS_DIGFILT_1SAMPLE_gc;
00018c e0e0      	LDI  R30,LOW(0)
00018d 93e0 018b 	STS  395,R30
                 ; 0000 0065 // Event System Channel 4 Digital Filter Coefficient: 1 Sample
                 ; 0000 0066 // Quadrature Decoder: Off
                 ; 0000 0067 EVSYS.CH4CTRL=(EVSYS.CH4CTRL & (~(EVSYS_QDIRM_gm | EVSYS_QDIEN_bm | EVSYS_QDEN_bm | EVSYS_DIGFILT_gm))) |
                 ; 0000 0068 	EVSYS_DIGFILT_1SAMPLE_gc;
00018f 91e0 018c 	LDS  R30,396
000191 78e0      	ANDI R30,LOW(0x80)
000192 93e0 018c 	STS  396,R30
                 ; 0000 0069 // Event System Channel 5 Digital Filter Coefficient: 1 Sample
                 ; 0000 006A EVSYS.CH5CTRL=EVSYS_DIGFILT_1SAMPLE_gc;
000194 e0e0      	LDI  R30,LOW(0)
000195 93e0 018d 	STS  397,R30
                 ; 0000 006B // Event System Channel 6 Digital Filter Coefficient: 1 Sample
                 ; 0000 006C EVSYS.CH6CTRL=EVSYS_DIGFILT_1SAMPLE_gc;
000197 93e0 018e 	STS  398,R30
                 ; 0000 006D // Event System Channel 7 Digital Filter Coefficient: 1 Sample
                 ; 0000 006E EVSYS.CH7CTRL=EVSYS_DIGFILT_1SAMPLE_gc;
000199 93e0 018f 	STS  399,R30
                 ; 0000 006F 
                 ; 0000 0070 // Event System Channel output: Disabled
                 ; 0000 0071 PORTCFG.CLKEVOUT&= ~PORTCFG_EVOUT_gm;
00019b 91e0 00b4 	LDS  R30,180
00019d 7cef      	ANDI R30,LOW(0xCF)
00019e 93e0 00b4 	STS  180,R30
                 ; 0000 0072 PORTCFG.EVOUTSEL&= ~PORTCFG_EVOUTSEL_gm;
0001a0 91e0 00b6 	LDS  R30,182
0001a2 7fe8      	ANDI R30,LOW(0xF8)
0001a3 93e0 00b6 	STS  182,R30
                 ; 0000 0073 }
0001a5 9508      	RET
                 ; .FEND
                 ;
                 ;// Ports initialization
                 ;void ports_init(void)
                 ; 0000 0077 {
                 _ports_init:
                 ; .FSTART _ports_init
                 ; 0000 0078 // PORTA initialization
                 ; 0000 0079 // OUT register
                 ; 0000 007A PORTA.OUT=0x00;
0001a6 e0e0      	LDI  R30,LOW(0)
0001a7 93e0 0604 	STS  1540,R30
                 ; 0000 007B // Pin0: Input
                 ; 0000 007C // Pin1: Input
                 ; 0000 007D // Pin2: Input
                 ; 0000 007E // Pin3: Input
                 ; 0000 007F // Pin4: Input
                 ; 0000 0080 // Pin5: Input
                 ; 0000 0081 // Pin6: Input
                 ; 0000 0082 // Pin7: Input
                 ; 0000 0083 PORTA.DIR=0x00;
0001a9 93e0 0600 	STS  1536,R30
                 ; 0000 0084 // Pin0 Output/Pull configuration: Totempole/No
                 ; 0000 0085 // Pin0 Input/Sense configuration: Sense both edges
                 ; 0000 0086 // Pin0 Inverted: Off
                 ; 0000 0087 // Pin0 Slew Rate Limitation: Off
                 ; 0000 0088 PORTA.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001ab 93e0 0610 	STS  1552,R30
                 ; 0000 0089 // Pin1 Output/Pull configuration: Totempole/No
                 ; 0000 008A // Pin1 Input/Sense configuration: Sense both edges
                 ; 0000 008B // Pin1 Inverted: Off
                 ; 0000 008C // Pin1 Slew Rate Limitation: Off
                 ; 0000 008D PORTA.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001ad 93e0 0611 	STS  1553,R30
                 ; 0000 008E // Pin2 Output/Pull configuration: Totempole/No
                 ; 0000 008F // Pin2 Input/Sense configuration: Sense both edges
                 ; 0000 0090 // Pin2 Inverted: Off
                 ; 0000 0091 // Pin2 Slew Rate Limitation: Off
                 ; 0000 0092 PORTA.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001af 93e0 0612 	STS  1554,R30
                 ; 0000 0093 // Pin3 Output/Pull configuration: Totempole/No
                 ; 0000 0094 // Pin3 Input/Sense configuration: Sense both edges
                 ; 0000 0095 // Pin3 Inverted: Off
                 ; 0000 0096 // Pin3 Slew Rate Limitation: Off
                 ; 0000 0097 PORTA.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001b1 93e0 0613 	STS  1555,R30
                 ; 0000 0098 // Pin4 Output/Pull configuration: Totempole/No
                 ; 0000 0099 // Pin4 Input/Sense configuration: Sense both edges
                 ; 0000 009A // Pin4 Inverted: Off
                 ; 0000 009B // Pin4 Slew Rate Limitation: Off
                 ; 0000 009C PORTA.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001b3 93e0 0614 	STS  1556,R30
                 ; 0000 009D // Pin5 Output/Pull configuration: Totempole/No
                 ; 0000 009E // Pin5 Input/Sense configuration: Sense both edges
                 ; 0000 009F // Pin5 Inverted: Off
                 ; 0000 00A0 // Pin5 Slew Rate Limitation: Off
                 ; 0000 00A1 PORTA.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001b5 93e0 0615 	STS  1557,R30
                 ; 0000 00A2 // Pin6 Output/Pull configuration: Totempole/No
                 ; 0000 00A3 // Pin6 Input/Sense configuration: Sense both edges
                 ; 0000 00A4 // Pin6 Inverted: Off
                 ; 0000 00A5 // Pin6 Slew Rate Limitation: Off
                 ; 0000 00A6 PORTA.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001b7 93e0 0616 	STS  1558,R30
                 ; 0000 00A7 // Pin7 Output/Pull configuration: Totempole/No
                 ; 0000 00A8 // Pin7 Input/Sense configuration: Sense both edges
                 ; 0000 00A9 // Pin7 Inverted: Off
                 ; 0000 00AA // Pin7 Slew Rate Limitation: Off
                 ; 0000 00AB PORTA.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001b9 93e0 0617 	STS  1559,R30
                 ; 0000 00AC // Interrupt 0 level: Disabled
                 ; 0000 00AD // Interrupt 1 level: Disabled
                 ; 0000 00AE PORTA.INTCTRL=(PORTA.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
                 ; 0000 00AF     PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
0001bb 91e0 0609 	LDS  R30,1545
0001bd 7fe0      	ANDI R30,LOW(0xF0)
0001be 93e0 0609 	STS  1545,R30
                 ; 0000 00B0 // Pin0 Pin Change interrupt 0: Off
                 ; 0000 00B1 // Pin1 Pin Change interrupt 0: Off
                 ; 0000 00B2 // Pin2 Pin Change interrupt 0: Off
                 ; 0000 00B3 // Pin3 Pin Change interrupt 0: Off
                 ; 0000 00B4 // Pin4 Pin Change interrupt 0: Off
                 ; 0000 00B5 // Pin5 Pin Change interrupt 0: Off
                 ; 0000 00B6 // Pin6 Pin Change interrupt 0: Off
                 ; 0000 00B7 // Pin7 Pin Change interrupt 0: Off
                 ; 0000 00B8 PORTA.INT0MASK=0x00;
0001c0 e0e0      	LDI  R30,LOW(0)
0001c1 93e0 060a 	STS  1546,R30
                 ; 0000 00B9 // Pin0 Pin Change interrupt 1: Off
                 ; 0000 00BA // Pin1 Pin Change interrupt 1: Off
                 ; 0000 00BB // Pin2 Pin Change interrupt 1: Off
                 ; 0000 00BC // Pin3 Pin Change interrupt 1: Off
                 ; 0000 00BD // Pin4 Pin Change interrupt 1: Off
                 ; 0000 00BE // Pin5 Pin Change interrupt 1: Off
                 ; 0000 00BF // Pin6 Pin Change interrupt 1: Off
                 ; 0000 00C0 // Pin7 Pin Change interrupt 1: Off
                 ; 0000 00C1 PORTA.INT1MASK=0x00;
0001c3 93e0 060b 	STS  1547,R30
                 ; 0000 00C2 
                 ; 0000 00C3 // PORTB initialization
                 ; 0000 00C4 // OUT register
                 ; 0000 00C5 PORTB.OUT=0x00;
0001c5 93e0 0624 	STS  1572,R30
                 ; 0000 00C6 // Pin0: Input
                 ; 0000 00C7 // Pin1: Input
                 ; 0000 00C8 // Pin2: Input
                 ; 0000 00C9 // Pin3: Input
                 ; 0000 00CA // Pin4: Input
                 ; 0000 00CB // Pin5: Input
                 ; 0000 00CC // Pin6: Input
                 ; 0000 00CD // Pin7: Input
                 ; 0000 00CE PORTB.DIR=0x00;
0001c7 93e0 0620 	STS  1568,R30
                 ; 0000 00CF // Pin0 Output/Pull configuration: Totempole/No
                 ; 0000 00D0 // Pin0 Input/Sense configuration: Sense both edges
                 ; 0000 00D1 // Pin0 Inverted: Off
                 ; 0000 00D2 // Pin0 Slew Rate Limitation: Off
                 ; 0000 00D3 PORTB.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001c9 93e0 0630 	STS  1584,R30
                 ; 0000 00D4 // Pin1 Output/Pull configuration: Totempole/No
                 ; 0000 00D5 // Pin1 Input/Sense configuration: Sense both edges
                 ; 0000 00D6 // Pin1 Inverted: Off
                 ; 0000 00D7 // Pin1 Slew Rate Limitation: Off
                 ; 0000 00D8 PORTB.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001cb 93e0 0631 	STS  1585,R30
                 ; 0000 00D9 // Pin2 Output/Pull configuration: Totempole/No
                 ; 0000 00DA // Pin2 Input/Sense configuration: Sense both edges
                 ; 0000 00DB // Pin2 Inverted: Off
                 ; 0000 00DC // Pin2 Slew Rate Limitation: Off
                 ; 0000 00DD PORTB.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001cd 93e0 0632 	STS  1586,R30
                 ; 0000 00DE // Pin3 Output/Pull configuration: Totempole/No
                 ; 0000 00DF // Pin3 Input/Sense configuration: Sense both edges
                 ; 0000 00E0 // Pin3 Inverted: Off
                 ; 0000 00E1 // Pin3 Slew Rate Limitation: Off
                 ; 0000 00E2 PORTB.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001cf 93e0 0633 	STS  1587,R30
                 ; 0000 00E3 // Pin4 Output/Pull configuration: Totempole/No
                 ; 0000 00E4 // Pin4 Input/Sense configuration: Sense both edges
                 ; 0000 00E5 // Pin4 Inverted: Off
                 ; 0000 00E6 // Pin4 Slew Rate Limitation: Off
                 ; 0000 00E7 PORTB.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001d1 93e0 0634 	STS  1588,R30
                 ; 0000 00E8 // Pin5 Output/Pull configuration: Totempole/No
                 ; 0000 00E9 // Pin5 Input/Sense configuration: Sense both edges
                 ; 0000 00EA // Pin5 Inverted: Off
                 ; 0000 00EB // Pin5 Slew Rate Limitation: Off
                 ; 0000 00EC PORTB.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001d3 93e0 0635 	STS  1589,R30
                 ; 0000 00ED // Pin6 Output/Pull configuration: Totempole/No
                 ; 0000 00EE // Pin6 Input/Sense configuration: Sense both edges
                 ; 0000 00EF // Pin6 Inverted: Off
                 ; 0000 00F0 // Pin6 Slew Rate Limitation: Off
                 ; 0000 00F1 PORTB.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001d5 93e0 0636 	STS  1590,R30
                 ; 0000 00F2 // Pin7 Output/Pull configuration: Totempole/No
                 ; 0000 00F3 // Pin7 Input/Sense configuration: Sense both edges
                 ; 0000 00F4 // Pin7 Inverted: Off
                 ; 0000 00F5 // Pin7 Slew Rate Limitation: Off
                 ; 0000 00F6 PORTB.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001d7 93e0 0637 	STS  1591,R30
                 ; 0000 00F7 // Interrupt 0 level: Disabled
                 ; 0000 00F8 // Interrupt 1 level: Disabled
                 ; 0000 00F9 PORTB.INTCTRL=(PORTB.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
                 ; 0000 00FA     PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
0001d9 91e0 0629 	LDS  R30,1577
0001db 7fe0      	ANDI R30,LOW(0xF0)
0001dc 93e0 0629 	STS  1577,R30
                 ; 0000 00FB // Pin0 Pin Change interrupt 0: Off
                 ; 0000 00FC // Pin1 Pin Change interrupt 0: Off
                 ; 0000 00FD // Pin2 Pin Change interrupt 0: Off
                 ; 0000 00FE // Pin3 Pin Change interrupt 0: Off
                 ; 0000 00FF // Pin4 Pin Change interrupt 0: Off
                 ; 0000 0100 // Pin5 Pin Change interrupt 0: Off
                 ; 0000 0101 // Pin6 Pin Change interrupt 0: Off
                 ; 0000 0102 // Pin7 Pin Change interrupt 0: Off
                 ; 0000 0103 PORTB.INT0MASK=0x00;
0001de e0e0      	LDI  R30,LOW(0)
0001df 93e0 062a 	STS  1578,R30
                 ; 0000 0104 // Pin0 Pin Change interrupt 1: Off
                 ; 0000 0105 // Pin1 Pin Change interrupt 1: Off
                 ; 0000 0106 // Pin2 Pin Change interrupt 1: Off
                 ; 0000 0107 // Pin3 Pin Change interrupt 1: Off
                 ; 0000 0108 // Pin4 Pin Change interrupt 1: Off
                 ; 0000 0109 // Pin5 Pin Change interrupt 1: Off
                 ; 0000 010A // Pin6 Pin Change interrupt 1: Off
                 ; 0000 010B // Pin7 Pin Change interrupt 1: Off
                 ; 0000 010C PORTB.INT1MASK=0x00;
0001e1 93e0 062b 	STS  1579,R30
                 ; 0000 010D 
                 ; 0000 010E // PORTC initialization
                 ; 0000 010F // OUT register
                 ; 0000 0110 PORTC.OUT=0x04;
0001e3 e0e4      	LDI  R30,LOW(4)
0001e4 93e0 0644 	STS  1604,R30
                 ; 0000 0111 // Pin0: Output
                 ; 0000 0112 // Pin1: Output
                 ; 0000 0113 // Pin2: Output
                 ; 0000 0114 // Pin3: Input
                 ; 0000 0115 // Pin4: Input
                 ; 0000 0116 // Pin5: Input
                 ; 0000 0117 // Pin6: Input
                 ; 0000 0118 // Pin7: Input
                 ; 0000 0119 PORTC.DIR=0x07;
0001e6 e0e7      	LDI  R30,LOW(7)
0001e7 93e0 0640 	STS  1600,R30
                 ; 0000 011A // Pin0 Output/Pull configuration: Totempole/No
                 ; 0000 011B // Pin0 Input/Sense configuration: Sense both edges
                 ; 0000 011C // Pin0 Inverted: Off
                 ; 0000 011D // Pin0 Slew Rate Limitation: Off
                 ; 0000 011E PORTC.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001e9 e0e0      	LDI  R30,LOW(0)
0001ea 93e0 0650 	STS  1616,R30
                 ; 0000 011F // Pin1 Output/Pull configuration: Totempole/No
                 ; 0000 0120 // Pin1 Input/Sense configuration: Sense both edges
                 ; 0000 0121 // Pin1 Inverted: Off
                 ; 0000 0122 // Pin1 Slew Rate Limitation: Off
                 ; 0000 0123 PORTC.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001ec 93e0 0651 	STS  1617,R30
                 ; 0000 0124 // Pin2 Output/Pull configuration: Totempole/No
                 ; 0000 0125 // Pin2 Input/Sense configuration: Sense both edges
                 ; 0000 0126 // Pin2 Inverted: Off
                 ; 0000 0127 // Pin2 Slew Rate Limitation: Off
                 ; 0000 0128 PORTC.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001ee 93e0 0652 	STS  1618,R30
                 ; 0000 0129 // Pin3 Output/Pull configuration: Totempole/No
                 ; 0000 012A // Pin3 Input/Sense configuration: Sense both edges
                 ; 0000 012B // Pin3 Inverted: Off
                 ; 0000 012C // Pin3 Slew Rate Limitation: Off
                 ; 0000 012D PORTC.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001f0 93e0 0653 	STS  1619,R30
                 ; 0000 012E // Pin4 Output/Pull configuration: Totempole/No
                 ; 0000 012F // Pin4 Input/Sense configuration: Sense both edges
                 ; 0000 0130 // Pin4 Inverted: Off
                 ; 0000 0131 // Pin4 Slew Rate Limitation: Off
                 ; 0000 0132 PORTC.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001f2 93e0 0654 	STS  1620,R30
                 ; 0000 0133 // Pin5 Output/Pull configuration: Totempole/No
                 ; 0000 0134 // Pin5 Input/Sense configuration: Sense both edges
                 ; 0000 0135 // Pin5 Inverted: Off
                 ; 0000 0136 // Pin5 Slew Rate Limitation: Off
                 ; 0000 0137 PORTC.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001f4 93e0 0655 	STS  1621,R30
                 ; 0000 0138 // Pin6 Output/Pull configuration: Totempole/No
                 ; 0000 0139 // Pin6 Input/Sense configuration: Sense both edges
                 ; 0000 013A // Pin6 Inverted: Off
                 ; 0000 013B // Pin6 Slew Rate Limitation: Off
                 ; 0000 013C PORTC.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001f6 93e0 0656 	STS  1622,R30
                 ; 0000 013D // Pin7 Output/Pull configuration: Totempole/No
                 ; 0000 013E // Pin7 Input/Sense configuration: Sense both edges
                 ; 0000 013F // Pin7 Inverted: Off
                 ; 0000 0140 // Pin7 Slew Rate Limitation: Off
                 ; 0000 0141 PORTC.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
0001f8 93e0 0657 	STS  1623,R30
                 ; 0000 0142 // PORTC Peripheral Output Remapping
                 ; 0000 0143 // OC0A Output: Pin 0
                 ; 0000 0144 // OC0B Output: Pin 1
                 ; 0000 0145 // OC0C Output: Pin 2
                 ; 0000 0146 // OC0D Output: Pin 3
                 ; 0000 0147 // USART0 XCK: Pin 1
                 ; 0000 0148 // USART0 RXD: Pin 2
                 ; 0000 0149 // USART0 TXD: Pin 3
                 ; 0000 014A // SPI MOSI: Pin 5
                 ; 0000 014B // SPI SCK: Pin 7
                 ; 0000 014C PORTC.REMAP=(0<<PORT_SPI_bp) | (0<<PORT_USART0_bp) | (0<<PORT_TC0D_bp) | (0<<PORT_TC0C_bp) | (0<<PORT_TC0B_bp) | (0<<POR ...
0001fa 93e0 064e 	STS  1614,R30
                 ; 0000 014D // Interrupt 0 level: Disabled
                 ; 0000 014E // Interrupt 1 level: Disabled
                 ; 0000 014F PORTC.INTCTRL=(PORTC.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
                 ; 0000 0150     PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
0001fc 91e0 0649 	LDS  R30,1609
0001fe 7fe0      	ANDI R30,LOW(0xF0)
0001ff 93e0 0649 	STS  1609,R30
                 ; 0000 0151 // Pin0 Pin Change interrupt 0: Off
                 ; 0000 0152 // Pin1 Pin Change interrupt 0: Off
                 ; 0000 0153 // Pin2 Pin Change interrupt 0: Off
                 ; 0000 0154 // Pin3 Pin Change interrupt 0: Off
                 ; 0000 0155 // Pin4 Pin Change interrupt 0: Off
                 ; 0000 0156 // Pin5 Pin Change interrupt 0: Off
                 ; 0000 0157 // Pin6 Pin Change interrupt 0: Off
                 ; 0000 0158 // Pin7 Pin Change interrupt 0: Off
                 ; 0000 0159 PORTC.INT0MASK=0x00;
000201 e0e0      	LDI  R30,LOW(0)
000202 93e0 064a 	STS  1610,R30
                 ; 0000 015A // Pin0 Pin Change interrupt 1: Off
                 ; 0000 015B // Pin1 Pin Change interrupt 1: Off
                 ; 0000 015C // Pin2 Pin Change interrupt 1: Off
                 ; 0000 015D // Pin3 Pin Change interrupt 1: Off
                 ; 0000 015E // Pin4 Pin Change interrupt 1: Off
                 ; 0000 015F // Pin5 Pin Change interrupt 1: Off
                 ; 0000 0160 // Pin6 Pin Change interrupt 1: Off
                 ; 0000 0161 // Pin7 Pin Change interrupt 1: Off
                 ; 0000 0162 PORTC.INT1MASK=0x00;
000204 93e0 064b 	STS  1611,R30
                 ; 0000 0163 
                 ; 0000 0164 // PORTD initialization
                 ; 0000 0165 // OUT register
                 ; 0000 0166 PORTD.OUT=0x00;
000206 93e0 0664 	STS  1636,R30
                 ; 0000 0167 // Pin0: Input
                 ; 0000 0168 // Pin1: Input
                 ; 0000 0169 // Pin2: Input
                 ; 0000 016A // Pin3: Input
                 ; 0000 016B // Pin4: Output
                 ; 0000 016C // Pin5: Output
                 ; 0000 016D // Pin6: Output
                 ; 0000 016E // Pin7: Output
                 ; 0000 016F PORTD.DIR=0xF0;
000208 efe0      	LDI  R30,LOW(240)
000209 93e0 0660 	STS  1632,R30
                 ; 0000 0170 // Pin0 Output/Pull configuration: Totempole/No
                 ; 0000 0171 // Pin0 Input/Sense configuration: Sense both edges
                 ; 0000 0172 // Pin0 Inverted: Off
                 ; 0000 0173 // Pin0 Slew Rate Limitation: Off
                 ; 0000 0174 PORTD.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00020b e0e0      	LDI  R30,LOW(0)
00020c 93e0 0670 	STS  1648,R30
                 ; 0000 0175 // Pin1 Output/Pull configuration: Totempole/No
                 ; 0000 0176 // Pin1 Input/Sense configuration: Sense both edges
                 ; 0000 0177 // Pin1 Inverted: Off
                 ; 0000 0178 // Pin1 Slew Rate Limitation: Off
                 ; 0000 0179 PORTD.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00020e 93e0 0671 	STS  1649,R30
                 ; 0000 017A // Pin2 Output/Pull configuration: Totempole/No
                 ; 0000 017B // Pin2 Input/Sense configuration: Sense both edges
                 ; 0000 017C // Pin2 Inverted: Off
                 ; 0000 017D // Pin2 Slew Rate Limitation: Off
                 ; 0000 017E PORTD.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000210 93e0 0672 	STS  1650,R30
                 ; 0000 017F // Pin3 Output/Pull configuration: Totempole/No
                 ; 0000 0180 // Pin3 Input/Sense configuration: Sense both edges
                 ; 0000 0181 // Pin3 Inverted: Off
                 ; 0000 0182 // Pin3 Slew Rate Limitation: Off
                 ; 0000 0183 PORTD.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000212 93e0 0673 	STS  1651,R30
                 ; 0000 0184 // Pin4 Output/Pull configuration: Totempole/No
                 ; 0000 0185 // Pin4 Input/Sense configuration: Sense both edges
                 ; 0000 0186 // Pin4 Inverted: Off
                 ; 0000 0187 // Pin4 Slew Rate Limitation: Off
                 ; 0000 0188 PORTD.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000214 93e0 0674 	STS  1652,R30
                 ; 0000 0189 // Pin5 Output/Pull configuration: Totempole/No
                 ; 0000 018A // Pin5 Input/Sense configuration: Sense both edges
                 ; 0000 018B // Pin5 Inverted: Off
                 ; 0000 018C // Pin5 Slew Rate Limitation: Off
                 ; 0000 018D PORTD.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000216 93e0 0675 	STS  1653,R30
                 ; 0000 018E // Pin6 Output/Pull configuration: Totempole/No
                 ; 0000 018F // Pin6 Input/Sense configuration: Sense both edges
                 ; 0000 0190 // Pin6 Inverted: Off
                 ; 0000 0191 // Pin6 Slew Rate Limitation: Off
                 ; 0000 0192 PORTD.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000218 93e0 0676 	STS  1654,R30
                 ; 0000 0193 // Pin7 Output/Pull configuration: Totempole/No
                 ; 0000 0194 // Pin7 Input/Sense configuration: Sense both edges
                 ; 0000 0195 // Pin7 Inverted: Off
                 ; 0000 0196 // Pin7 Slew Rate Limitation: Off
                 ; 0000 0197 PORTD.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00021a 93e0 0677 	STS  1655,R30
                 ; 0000 0198 // Interrupt 0 level: Disabled
                 ; 0000 0199 // Interrupt 1 level: Disabled
                 ; 0000 019A PORTD.INTCTRL=(PORTD.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
                 ; 0000 019B     PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
00021c 91e0 0669 	LDS  R30,1641
00021e 7fe0      	ANDI R30,LOW(0xF0)
00021f 93e0 0669 	STS  1641,R30
                 ; 0000 019C // Pin0 Pin Change interrupt 0: Off
                 ; 0000 019D // Pin1 Pin Change interrupt 0: Off
                 ; 0000 019E // Pin2 Pin Change interrupt 0: Off
                 ; 0000 019F // Pin3 Pin Change interrupt 0: Off
                 ; 0000 01A0 // Pin4 Pin Change interrupt 0: Off
                 ; 0000 01A1 // Pin5 Pin Change interrupt 0: Off
                 ; 0000 01A2 // Pin6 Pin Change interrupt 0: Off
                 ; 0000 01A3 // Pin7 Pin Change interrupt 0: Off
                 ; 0000 01A4 PORTD.INT0MASK=0x00;
000221 e0e0      	LDI  R30,LOW(0)
000222 93e0 066a 	STS  1642,R30
                 ; 0000 01A5 // Pin0 Pin Change interrupt 1: Off
                 ; 0000 01A6 // Pin1 Pin Change interrupt 1: Off
                 ; 0000 01A7 // Pin2 Pin Change interrupt 1: Off
                 ; 0000 01A8 // Pin3 Pin Change interrupt 1: Off
                 ; 0000 01A9 // Pin4 Pin Change interrupt 1: Off
                 ; 0000 01AA // Pin5 Pin Change interrupt 1: Off
                 ; 0000 01AB // Pin6 Pin Change interrupt 1: Off
                 ; 0000 01AC // Pin7 Pin Change interrupt 1: Off
                 ; 0000 01AD PORTD.INT1MASK=0x00;
000224 93e0 066b 	STS  1643,R30
                 ; 0000 01AE 
                 ; 0000 01AF // PORTE initialization
                 ; 0000 01B0 // OUT register
                 ; 0000 01B1 PORTE.OUT=0x00;
000226 93e0 0684 	STS  1668,R30
                 ; 0000 01B2 // Pin0: Output
                 ; 0000 01B3 // Pin1: Output
                 ; 0000 01B4 // Pin2: Output
                 ; 0000 01B5 // Pin3: Output
                 ; 0000 01B6 // Pin4: Output
                 ; 0000 01B7 // Pin5: Output
                 ; 0000 01B8 // Pin6: Output
                 ; 0000 01B9 // Pin7: Output
                 ; 0000 01BA PORTE.DIR=0xFF;
000228 efef      	LDI  R30,LOW(255)
000229 93e0 0680 	STS  1664,R30
                 ; 0000 01BB // Pin0 Output/Pull configuration: Totempole/No
                 ; 0000 01BC // Pin0 Input/Sense configuration: Sense both edges
                 ; 0000 01BD // Pin0 Inverted: Off
                 ; 0000 01BE // Pin0 Slew Rate Limitation: Off
                 ; 0000 01BF PORTE.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00022b e0e0      	LDI  R30,LOW(0)
00022c 93e0 0690 	STS  1680,R30
                 ; 0000 01C0 // Pin1 Output/Pull configuration: Totempole/No
                 ; 0000 01C1 // Pin1 Input/Sense configuration: Sense both edges
                 ; 0000 01C2 // Pin1 Inverted: Off
                 ; 0000 01C3 // Pin1 Slew Rate Limitation: Off
                 ; 0000 01C4 PORTE.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00022e 93e0 0691 	STS  1681,R30
                 ; 0000 01C5 // Pin2 Output/Pull configuration: Totempole/No
                 ; 0000 01C6 // Pin2 Input/Sense configuration: Sense both edges
                 ; 0000 01C7 // Pin2 Inverted: Off
                 ; 0000 01C8 // Pin2 Slew Rate Limitation: Off
                 ; 0000 01C9 PORTE.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000230 93e0 0692 	STS  1682,R30
                 ; 0000 01CA // Pin3 Output/Pull configuration: Totempole/No
                 ; 0000 01CB // Pin3 Input/Sense configuration: Sense both edges
                 ; 0000 01CC // Pin3 Inverted: Off
                 ; 0000 01CD // Pin3 Slew Rate Limitation: Off
                 ; 0000 01CE PORTE.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000232 93e0 0693 	STS  1683,R30
                 ; 0000 01CF // Pin4 Output/Pull configuration: Totempole/No
                 ; 0000 01D0 // Pin4 Input/Sense configuration: Sense both edges
                 ; 0000 01D1 // Pin4 Inverted: Off
                 ; 0000 01D2 // Pin4 Slew Rate Limitation: Off
                 ; 0000 01D3 PORTE.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000234 93e0 0694 	STS  1684,R30
                 ; 0000 01D4 // Pin5 Output/Pull configuration: Totempole/No
                 ; 0000 01D5 // Pin5 Input/Sense configuration: Sense both edges
                 ; 0000 01D6 // Pin5 Inverted: Off
                 ; 0000 01D7 // Pin5 Slew Rate Limitation: Off
                 ; 0000 01D8 PORTE.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000236 93e0 0695 	STS  1685,R30
                 ; 0000 01D9 // Pin6 Output/Pull configuration: Totempole/No
                 ; 0000 01DA // Pin6 Input/Sense configuration: Sense both edges
                 ; 0000 01DB // Pin6 Inverted: Off
                 ; 0000 01DC // Pin6 Slew Rate Limitation: Off
                 ; 0000 01DD PORTE.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000238 93e0 0696 	STS  1686,R30
                 ; 0000 01DE // Pin7 Output/Pull configuration: Totempole/No
                 ; 0000 01DF // Pin7 Input/Sense configuration: Sense both edges
                 ; 0000 01E0 // Pin7 Inverted: Off
                 ; 0000 01E1 // Pin7 Slew Rate Limitation: Off
                 ; 0000 01E2 PORTE.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00023a 93e0 0697 	STS  1687,R30
                 ; 0000 01E3 // Interrupt 0 level: Disabled
                 ; 0000 01E4 // Interrupt 1 level: Disabled
                 ; 0000 01E5 PORTE.INTCTRL=(PORTE.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
                 ; 0000 01E6     PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
00023c 91e0 0689 	LDS  R30,1673
00023e 7fe0      	ANDI R30,LOW(0xF0)
00023f 93e0 0689 	STS  1673,R30
                 ; 0000 01E7 // Pin0 Pin Change interrupt 0: Off
                 ; 0000 01E8 // Pin1 Pin Change interrupt 0: Off
                 ; 0000 01E9 // Pin2 Pin Change interrupt 0: Off
                 ; 0000 01EA // Pin3 Pin Change interrupt 0: Off
                 ; 0000 01EB // Pin4 Pin Change interrupt 0: Off
                 ; 0000 01EC // Pin5 Pin Change interrupt 0: Off
                 ; 0000 01ED // Pin6 Pin Change interrupt 0: Off
                 ; 0000 01EE // Pin7 Pin Change interrupt 0: Off
                 ; 0000 01EF PORTE.INT0MASK=0x00;
000241 e0e0      	LDI  R30,LOW(0)
000242 93e0 068a 	STS  1674,R30
                 ; 0000 01F0 // Pin0 Pin Change interrupt 1: Off
                 ; 0000 01F1 // Pin1 Pin Change interrupt 1: Off
                 ; 0000 01F2 // Pin2 Pin Change interrupt 1: Off
                 ; 0000 01F3 // Pin3 Pin Change interrupt 1: Off
                 ; 0000 01F4 // Pin4 Pin Change interrupt 1: Off
                 ; 0000 01F5 // Pin5 Pin Change interrupt 1: Off
                 ; 0000 01F6 // Pin6 Pin Change interrupt 1: Off
                 ; 0000 01F7 // Pin7 Pin Change interrupt 1: Off
                 ; 0000 01F8 PORTE.INT1MASK=0x00;
000244 93e0 068b 	STS  1675,R30
                 ; 0000 01F9 
                 ; 0000 01FA // PORTF initialization
                 ; 0000 01FB // OUT register
                 ; 0000 01FC PORTF.OUT=0x00;
000246 93e0 06a4 	STS  1700,R30
                 ; 0000 01FD // Pin0: Input
                 ; 0000 01FE // Pin1: Input
                 ; 0000 01FF // Pin2: Input
                 ; 0000 0200 // Pin3: Output
                 ; 0000 0201 // Pin4: Input
                 ; 0000 0202 // Pin5: Input
                 ; 0000 0203 // Pin6: Input
                 ; 0000 0204 // Pin7: Input
                 ; 0000 0205 PORTF.DIR=0x08;
000248 e0e8      	LDI  R30,LOW(8)
000249 93e0 06a0 	STS  1696,R30
                 ; 0000 0206 // Pin0 Output/Pull configuration: Totempole/No
                 ; 0000 0207 // Pin0 Input/Sense configuration: Sense both edges
                 ; 0000 0208 // Pin0 Inverted: Off
                 ; 0000 0209 // Pin0 Slew Rate Limitation: Off
                 ; 0000 020A PORTF.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00024b e0e0      	LDI  R30,LOW(0)
00024c 93e0 06b0 	STS  1712,R30
                 ; 0000 020B // Pin1 Output/Pull configuration: Totempole/No
                 ; 0000 020C // Pin1 Input/Sense configuration: Sense both edges
                 ; 0000 020D // Pin1 Inverted: Off
                 ; 0000 020E // Pin1 Slew Rate Limitation: Off
                 ; 0000 020F PORTF.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00024e 93e0 06b1 	STS  1713,R30
                 ; 0000 0210 // Pin2 Output/Pull configuration: Totempole/No
                 ; 0000 0211 // Pin2 Input/Sense configuration: Sense both edges
                 ; 0000 0212 // Pin2 Inverted: Off
                 ; 0000 0213 // Pin2 Slew Rate Limitation: Off
                 ; 0000 0214 PORTF.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000250 93e0 06b2 	STS  1714,R30
                 ; 0000 0215 // Pin3 Output/Pull configuration: Totempole/No
                 ; 0000 0216 // Pin3 Input/Sense configuration: Sense both edges
                 ; 0000 0217 // Pin3 Inverted: Off
                 ; 0000 0218 // Pin3 Slew Rate Limitation: Off
                 ; 0000 0219 PORTF.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000252 93e0 06b3 	STS  1715,R30
                 ; 0000 021A // Pin4 Output/Pull configuration: Totempole/No
                 ; 0000 021B // Pin4 Input/Sense configuration: Sense both edges
                 ; 0000 021C // Pin4 Inverted: Off
                 ; 0000 021D // Pin4 Slew Rate Limitation: Off
                 ; 0000 021E PORTF.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000254 93e0 06b4 	STS  1716,R30
                 ; 0000 021F // Pin5 Output/Pull configuration: Totempole/No
                 ; 0000 0220 // Pin5 Input/Sense configuration: Sense both edges
                 ; 0000 0221 // Pin5 Inverted: Off
                 ; 0000 0222 // Pin5 Slew Rate Limitation: Off
                 ; 0000 0223 PORTF.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000256 93e0 06b5 	STS  1717,R30
                 ; 0000 0224 // Pin6 Output/Pull configuration: Totempole/No
                 ; 0000 0225 // Pin6 Input/Sense configuration: Sense both edges
                 ; 0000 0226 // Pin6 Inverted: Off
                 ; 0000 0227 // Pin6 Slew Rate Limitation: Off
                 ; 0000 0228 PORTF.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
000258 93e0 06b6 	STS  1718,R30
                 ; 0000 0229 // Pin7 Output/Pull configuration: Totempole/No
                 ; 0000 022A // Pin7 Input/Sense configuration: Sense both edges
                 ; 0000 022B // Pin7 Inverted: Off
                 ; 0000 022C // Pin7 Slew Rate Limitation: Off
                 ; 0000 022D PORTF.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00025a 93e0 06b7 	STS  1719,R30
                 ; 0000 022E // Interrupt 0 level: Disabled
                 ; 0000 022F // Interrupt 1 level: Disabled
                 ; 0000 0230 PORTF.INTCTRL=(PORTF.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
                 ; 0000 0231 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
00025c 91e0 06a9 	LDS  R30,1705
00025e 7fe0      	ANDI R30,LOW(0xF0)
00025f 93e0 06a9 	STS  1705,R30
                 ; 0000 0232 // Pin0 Pin Change interrupt 0: Off
                 ; 0000 0233 // Pin1 Pin Change interrupt 0: Off
                 ; 0000 0234 // Pin2 Pin Change interrupt 0: Off
                 ; 0000 0235 // Pin3 Pin Change interrupt 0: Off
                 ; 0000 0236 // Pin4 Pin Change interrupt 0: Off
                 ; 0000 0237 // Pin5 Pin Change interrupt 0: Off
                 ; 0000 0238 // Pin6 Pin Change interrupt 0: Off
                 ; 0000 0239 // Pin7 Pin Change interrupt 0: Off
                 ; 0000 023A PORTF.INT0MASK=0x00;
000261 e0e0      	LDI  R30,LOW(0)
000262 93e0 06aa 	STS  1706,R30
                 ; 0000 023B // Pin0 Pin Change interrupt 1: Off
                 ; 0000 023C // Pin1 Pin Change interrupt 1: Off
                 ; 0000 023D // Pin2 Pin Change interrupt 1: Off
                 ; 0000 023E // Pin3 Pin Change interrupt 1: Off
                 ; 0000 023F // Pin4 Pin Change interrupt 1: Off
                 ; 0000 0240 // Pin5 Pin Change interrupt 1: Off
                 ; 0000 0241 // Pin6 Pin Change interrupt 1: Off
                 ; 0000 0242 // Pin7 Pin Change interrupt 1: Off
                 ; 0000 0243 PORTF.INT1MASK=0x00;
000264 93e0 06ab 	STS  1707,R30
                 ; 0000 0244 
                 ; 0000 0245 // PORTR initialization
                 ; 0000 0246 // OUT register
                 ; 0000 0247 PORTR.OUT=0x00;
000266 93e0 07e4 	STS  2020,R30
                 ; 0000 0248 // Pin0: Input
                 ; 0000 0249 // Pin1: Input
                 ; 0000 024A PORTR.DIR=0x00;
000268 93e0 07e0 	STS  2016,R30
                 ; 0000 024B // Pin0 Output/Pull configuration: Totempole/No
                 ; 0000 024C // Pin0 Input/Sense configuration: Sense both edges
                 ; 0000 024D // Pin0 Inverted: Off
                 ; 0000 024E // Pin0 Slew Rate Limitation: Off
                 ; 0000 024F PORTR.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00026a 93e0 07f0 	STS  2032,R30
                 ; 0000 0250 // Pin1 Output/Pull configuration: Totempole/No
                 ; 0000 0251 // Pin1 Input/Sense configuration: Sense both edges
                 ; 0000 0252 // Pin1 Inverted: Off
                 ; 0000 0253 // Pin1 Slew Rate Limitation: Off
                 ; 0000 0254 PORTR.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc;
00026c 93e0 07f1 	STS  2033,R30
                 ; 0000 0255 // Interrupt 0 level: Disabled
                 ; 0000 0256 // Interrupt 1 level: Disabled
                 ; 0000 0257 PORTR.INTCTRL=(PORTR.INTCTRL & (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) |
                 ; 0000 0258 	PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc;
00026e 91e0 07e9 	LDS  R30,2025
000270 7fe0      	ANDI R30,LOW(0xF0)
000271 93e0 07e9 	STS  2025,R30
                 ; 0000 0259 // Pin0 Pin Change interrupt 0: Off
                 ; 0000 025A // Pin1 Pin Change interrupt 0: Off
                 ; 0000 025B PORTR.INT0MASK=0x00;
000273 e0e0      	LDI  R30,LOW(0)
000274 93e0 07ea 	STS  2026,R30
                 ; 0000 025C // Pin0 Pin Change interrupt 1: Off
                 ; 0000 025D // Pin1 Pin Change interrupt 1: Off
                 ; 0000 025E PORTR.INT1MASK=0x00;
000276 93e0 07eb 	STS  2027,R30
                 ; 0000 025F }
000278 9508      	RET
                 ; .FEND
                 ;
                 ;// Virtual Ports initialization
                 ;void vports_init(void)
                 ; 0000 0263 {
                 _vports_init:
                 ; .FSTART _vports_init
                 ; 0000 0264 // PORTA mapped to VPORT0
                 ; 0000 0265 // PORTB mapped to VPORT1
                 ; 0000 0266 PORTCFG.VPCTRLA=PORTCFG_VP13MAP_PORTB_gc | PORTCFG_VP02MAP_PORTA_gc;
000279 e1e0      	LDI  R30,LOW(16)
00027a 93e0 00b2 	STS  178,R30
                 ; 0000 0267 // PORTC mapped to VPORT2
                 ; 0000 0268 // PORTD mapped to VPORT3
                 ; 0000 0269 PORTCFG.VPCTRLB=PORTCFG_VP13MAP_PORTD_gc | PORTCFG_VP02MAP_PORTC_gc;
00027c e3e2      	LDI  R30,LOW(50)
00027d 93e0 00b3 	STS  179,R30
                 ; 0000 026A }
00027f 9508      	RET
                 ; .FEND
                 ;
                 ;// USARTF0 initialization
                 ;void usartf0_init(void)
                 ; 0000 026E {
                 _usartf0_init:
                 ; .FSTART _usartf0_init
                 ; 0000 026F // Note: The correct PORTF direction for the RxD, TxD and XCK signals
                 ; 0000 0270 // is configured in the ports_init function.
                 ; 0000 0271 
                 ; 0000 0272 // Transmitter is enabled
                 ; 0000 0273 // Set TxD=1
                 ; 0000 0274 PORTF.OUTSET=0x08;
000280 e0e8      	LDI  R30,LOW(8)
000281 93e0 06a5 	STS  1701,R30
                 ; 0000 0275 
                 ; 0000 0276 // Communication mode: Asynchronous USART
                 ; 0000 0277 // Data bits: 8
                 ; 0000 0278 // Stop bits: 1
                 ; 0000 0279 // Parity: Disabled
                 ; 0000 027A USARTF0.CTRLC=USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | USART_CHSIZE_8BIT_gc;
000283 e0e3      	LDI  R30,LOW(3)
000284 93e0 0ba5 	STS  2981,R30
                 ; 0000 027B 
                 ; 0000 027C // Receive complete interrupt: High Level
                 ; 0000 027D // Transmit complete interrupt: Medium Level
                 ; 0000 027E // Data register empty interrupt: Disabled
                 ; 0000 027F USARTF0.CTRLA=(USARTF0.CTRLA & (~(USART_RXCINTLVL_gm | USART_TXCINTLVL_gm | USART_DREINTLVL_gm))) |
                 ; 0000 0280 	USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_MED_gc | USART_DREINTLVL_OFF_gc;
000286 91e0 0ba3 	LDS  R30,2979
000288 7ce0      	ANDI R30,LOW(0xC0)
000289 63e8      	ORI  R30,LOW(0x38)
00028a 93e0 0ba3 	STS  2979,R30
                 ; 0000 0281 
                 ; 0000 0282 // Required Baud rate: 115200
                 ; 0000 0283 // Real Baud Rate: 115211.5 (x1 Mode), Error: 0.0 %
                 ; 0000 0284 USARTF0.BAUDCTRLA=0x2E;
00028c e2ee      	LDI  R30,LOW(46)
00028d 93e0 0ba6 	STS  2982,R30
                 ; 0000 0285 USARTF0.BAUDCTRLB=((0x09 << USART_BSCALE_gp) & USART_BSCALE_gm) | 0x08;
00028f e9e8      	LDI  R30,LOW(152)
000290 93e0 0ba7 	STS  2983,R30
                 ; 0000 0286 
                 ; 0000 0287 // Receiver: On
                 ; 0000 0288 // Transmitter: On
                 ; 0000 0289 // Double transmission speed mode: Off
                 ; 0000 028A // Multi-processor communication mode: Off
                 ; 0000 028B USARTF0.CTRLB=(USARTF0.CTRLB & (~(USART_RXEN_bm | USART_TXEN_bm | USART_CLK2X_bm | USART_MPCM_bm | USART_TXB8_bm))) |
                 ; 0000 028C 	USART_RXEN_bm | USART_TXEN_bm;
000292 91e0 0ba4 	LDS  R30,2980
000294 7ee0      	ANDI R30,LOW(0xE0)
000295 61e8      	ORI  R30,LOW(0x18)
000296 93e0 0ba4 	STS  2980,R30
                 ; 0000 028D }
000298 9508      	RET
                 ; .FEND
                 ;
                 ;// USARTF0 Receiver buffer
                 ;#define RX_BUFFER_SIZE_USARTF0 64
                 ;char rx_buffer_usartf0[RX_BUFFER_SIZE_USARTF0];
                 ;
                 ;#if RX_BUFFER_SIZE_USARTF0 <= 256
                 ;unsigned char rx_wr_index_usartf0=0,rx_rd_index_usartf0=0;
                 ;#else
                 ;unsigned int rx_wr_index_usartf0=0,rx_rd_index_usartf0=0;
                 ;#endif
                 ;
                 ;#if RX_BUFFER_SIZE_USARTF0 < 256
                 ;unsigned char rx_counter_usartf0=0;
                 ;#else
                 ;unsigned int rx_counter_usartf0=0;
                 ;#endif
                 ;
                 ;// This flag is set on USARTF0 Receiver buffer overflow
                 ;bit rx_buffer_overflow_usartf0=0;
                 ;
                 ;// USARTF0 Receiver interrupt service routine
                 ;interrupt [USARTF0_RXC_vect] void usartf0_rx_isr(void)
                 ; 0000 02A4 {
                 _usartf0_rx_isr:
                 ; .FSTART _usartf0_rx_isr
000299 920a      	ST   -Y,R0
00029a 93ea      	ST   -Y,R30
00029b 93fa      	ST   -Y,R31
00029c b7ef      	IN   R30,SREG
00029d 93ea      	ST   -Y,R30
                 ; 0000 02A5 unsigned char status;
                 ; 0000 02A6 char data;
                 ; 0000 02A7 int data0,data1,data2;
                 ; 0000 02A8 
                 ; 0000 02A9 status=USARTF0.STATUS;
00029e 9722      	SBIW R28,2
00029f 940e 06de 	CALL __SAVELOCR6
                 ;	status -> R17
                 ;	data -> R16
                 ;	data0 -> R18,R19
                 ;	data1 -> R20,R21
                 ;	data2 -> Y+6
0002a1 9110 0ba1 	LDS  R17,2977
                 ; 0000 02AA data=USARTF0.DATA;
0002a3 9100 0ba0 	LDS  R16,2976
                 ; 0000 02AB        /*
                 ; 0000 02AC if ((status & (USART_FERR_bm | USART_PERR_bm | USART_BUFOVF_bm)) == 0)
                 ; 0000 02AD    {
                 ; 0000 02AE    rx_buffer_usartf0[rx_wr_index_usartf0++]=data;
                 ; 0000 02AF    if(rx_wr_index_usartf0 == 5)
                 ; 0000 02B0    {
                 ; 0000 02B1    if(rx_buffer_usartf0[rx_wr_index_usartf0-5]=='A')
                 ; 0000 02B2    {
                 ; 0000 02B3    data0 = rx_buffer_usartf0[rx_wr_index_usartf0-4]-0x30;
                 ; 0000 02B4    data1 = rx_buffer_usartf0[rx_wr_index_usartf0-3]-0x30;
                 ; 0000 02B5    data2 = rx_buffer_usartf0[rx_wr_index_usartf0-2]-0x30;
                 ; 0000 02B6 
                 ; 0000 02B7    DAQ_data =  (data0*100) + ((data1)*10) + (data2);
                 ; 0000 02B8    f_DAQ_data=(float)(DAQ_data*40.95);
                 ; 0000 02B9    DAQ_data = (unsigned int) (f_DAQ_data);
                 ; 0000 02BA    putchar (DAQ_data>>8);
                 ; 0000 02BB    putchar (DAQ_data);
                 ; 0000 02BC //   DAQ_data = 4095;
                 ; 0000 02BD    rx_wr_index_usartf0=0;
                 ; 0000 02BE    dacb_write(0,DAQ_data);
                 ; 0000 02BF    }
                 ; 0000 02C0    }
                 ; 0000 02C1  //  putchar(rx_buffer_usartf0[(rx_wr_index_usartf0-1)]);
                 ; 0000 02C2 #if RX_BUFFER_SIZE_USARTF0 == 256
                 ; 0000 02C3    // special case for receiver buffer size=256
                 ; 0000 02C4    if (++rx_counter_usartf0 == 0) rx_buffer_overflow_usartf0=1;
                 ; 0000 02C5 #else
                 ; 0000 02C6    if (rx_wr_index_usartf0 == RX_BUFFER_SIZE_USARTF0) rx_wr_index_usartf0=0;
                 ; 0000 02C7    if (++rx_counter_usartf0 == RX_BUFFER_SIZE_USARTF0)
                 ; 0000 02C8       {
                 ; 0000 02C9       rx_counter_usartf0=0;
                 ; 0000 02CA       rx_buffer_overflow_usartf0=1;
                 ; 0000 02CB       }
                 ; 0000 02CC #endif
                 ; 0000 02CD    }*/
                 ; 0000 02CE      if((data==start_byte)&&(packet_start==0))
0002a5 1650      	CP   R5,R16
0002a6 f421      	BRNE _0x7
0002a7 2400      	CLR  R0
0002a8 140a      	CP   R0,R10
0002a9 040b      	CPC  R0,R11
0002aa f009      	BREQ _0x8
                 _0x7:
0002ab c006      	RJMP _0x6
                 _0x8:
                 ; 0000 02CF             {
                 ; 0000 02D0             //packet start________________________________
                 ; 0000 02D1             packet_start=1;                     //packet start
0002ac e0e1      	LDI  R30,LOW(1)
0002ad e0f0      	LDI  R31,HIGH(1)
0002ae 015f      	MOVW R10,R30
                 ; 0000 02D2             data_recieved = 0;                  //Byte Number Set
0002af 2488      	CLR  R8
0002b0 2499      	CLR  R9
                 ; 0000 02D3             requ_buffer[data_recieved]=data;  //Save data
0002b1 c023      	RJMP _0x59
                 ; 0000 02D4             data_recieved++;                    //Byte Number Set For next Byte
                 ; 0000 02D5             //____________________________________________
                 ; 0000 02D6             }
                 ; 0000 02D7         else if(packet_start==1)
                 _0x6:
0002b2 e0e1      	LDI  R30,LOW(1)
0002b3 e0f0      	LDI  R31,HIGH(1)
0002b4 15ea      	CP   R30,R10
0002b5 05fb      	CPC  R31,R11
0002b6 f509      	BRNE _0xA
                 ; 0000 02D8             {
                 ; 0000 02D9             //packet end__________________________________
                 ; 0000 02DA             if ( (data_recieved==(packet_size_request-1))&&(data==stop_byte))
0002b7 e0eb      	LDI  R30,LOW(11)
0002b8 e0f0      	LDI  R31,HIGH(11)
0002b9 15e8      	CP   R30,R8
0002ba 05f9      	CPC  R31,R9
0002bb f411      	BRNE _0xC
0002bc 1640      	CP   R4,R16
0002bd f009      	BREQ _0xD
                 _0xC:
0002be c009      	RJMP _0xB
                 _0xD:
                 ; 0000 02DB                 {
                 ; 0000 02DC                     packet_start=0;
0002bf 24aa      	CLR  R10
0002c0 24bb      	CLR  R11
                 ; 0000 02DD                     requ_buffer[data_recieved]=data;  //Save data
0002c1 01f4      	MOVW R30,R8
0002c2 940e 059c 	CALL SUBOPT_0x0
                 ; 0000 02DE                     data_recieved++;
                 ; 0000 02DF                     flag=1;
0002c4 e0e1      	LDI  R30,LOW(1)
0002c5 e0f0      	LDI  R31,HIGH(1)
0002c6 013f      	MOVW R6,R30
                 ; 0000 02E0 
                 ; 0000 02E1                 }
                 ; 0000 02E2             //____________________________________________
                 ; 0000 02E3 
                 ; 0000 02E4             //packet not end dnf__________________________
                 ; 0000 02E5             else if ( (data_recieved==(packet_size_request-1))&&(data!=stop_byte))
0002c7 c010      	RJMP _0xE
                 _0xB:
0002c8 e0eb      	LDI  R30,LOW(11)
0002c9 e0f0      	LDI  R31,HIGH(11)
0002ca 15e8      	CP   R30,R8
0002cb 05f9      	CPC  R31,R9
0002cc f411      	BRNE _0x10
0002cd 1640      	CP   R4,R16
0002ce f409      	BRNE _0x11
                 _0x10:
0002cf c005      	RJMP _0xF
                 _0x11:
                 ; 0000 02E6                 {
                 ; 0000 02E7                     packet_start=0;
0002d0 24aa      	CLR  R10
0002d1 24bb      	CLR  R11
                 ; 0000 02E8                     data_recieved = 0;
0002d2 2488      	CLR  R8
0002d3 2499      	CLR  R9
                 ; 0000 02E9                 }
                 ; 0000 02EA             //____________________________________________
                 ; 0000 02EB 
                 ; 0000 02EC             //packet is ok yet__________________________
                 ; 0000 02ED             else
0002d4 c003      	RJMP _0x12
                 _0xF:
                 ; 0000 02EE                 {
                 ; 0000 02EF                 requ_buffer[data_recieved]=data;  //Save data
                 _0x59:
0002d5 01f4      	MOVW R30,R8
0002d6 940e 059c 	CALL SUBOPT_0x0
                 ; 0000 02F0                 data_recieved++;
                 ; 0000 02F1                 }
                 _0x12:
                 _0xE:
                 ; 0000 02F2             //________________________________putchar____________
                 ; 0000 02F3             }
                 ; 0000 02F4 
                 ; 0000 02F5 
                 ; 0000 02F6 }
                 _0xA:
0002d8 940e 06e5 	CALL __LOADLOCR6
0002da 9628      	ADIW R28,8
0002db 91e9      	LD   R30,Y+
0002dc bfef      	OUT  SREG,R30
0002dd 91f9      	LD   R31,Y+
0002de 91e9      	LD   R30,Y+
0002df 9009      	LD   R0,Y+
0002e0 9518      	RETI
                 ; .FEND
                 ;
                 ;// Receive a character from USARTF0
                 ;// USARTF0 is used as the default input device by the 'getchar' function
                 ;#define _ALTERNATE_GETCHAR_
                 ;
                 ;#pragma used+
                 ;char getchar(void)
                 ; 0000 02FE {
                 ; 0000 02FF char data;
                 ; 0000 0300 
                 ; 0000 0301 while (rx_counter_usartf0==0);
                 ;	data -> R17
                 ; 0000 0302 data=rx_buffer_usartf0[rx_rd_index_usartf0++];
                 ; 0000 0303 #if RX_BUFFER_SIZE_USARTF0 != 256
                 ; 0000 0304 if (rx_rd_index_usartf0 == RX_BUFFER_SIZE_USARTF0) rx_rd_index_usartf0=0;
                 ; 0000 0305 #endif
                 ; 0000 0306 #asm("cli")
                 ; 0000 0307 --rx_counter_usartf0;
                 ; 0000 0308 #asm("sei")
                 ; 0000 0309 return data;
                 ; 0000 030A }
                 ;#pragma used-
                 ;
                 ;// USARTF0 Transmitter buffer
                 ;#define TX_BUFFER_SIZE_USARTF0 64
                 ;char tx_buffer_usartf0[TX_BUFFER_SIZE_USARTF0];
                 ;
                 ;#if TX_BUFFER_SIZE_USARTF0 <= 256
                 ;unsigned char tx_wr_index_usartf0=0,tx_rd_index_usartf0=0;
                 ;#else
                 ;unsigned int tx_wr_index_usartf0=0,tx_rd_index_usartf0=0;
                 ;#endif
                 ;
                 ;#if TX_BUFFER_SIZE_USARTF0 < 256
                 ;unsigned char tx_counter_usartf0=0;
                 ;#else
                 ;unsigned int tx_counter_usartf0=0;
                 ;#endif
                 ;
                 ;// USARTF0 Transmitter interrupt service routine
                 ;interrupt [USARTF0_TXC_vect] void usartf0_tx_isr(void)
                 ; 0000 031F {
                 _usartf0_tx_isr:
                 ; .FSTART _usartf0_tx_isr
0002e1 93aa      	ST   -Y,R26
0002e2 93ea      	ST   -Y,R30
0002e3 93fa      	ST   -Y,R31
0002e4 b7ef      	IN   R30,SREG
0002e5 93ea      	ST   -Y,R30
                 ; 0000 0320 if (tx_counter_usartf0)
0002e6 91e0 2492 	LDS  R30,_tx_counter_usartf0
0002e8 30e0      	CPI  R30,0
0002e9 f0b1      	BREQ _0x17
                 ; 0000 0321    {
                 ; 0000 0322    --tx_counter_usartf0;
0002ea 50e1      	SUBI R30,LOW(1)
0002eb 93e0 2492 	STS  _tx_counter_usartf0,R30
                 ; 0000 0323    USARTF0.DATA=tx_buffer_usartf0[tx_rd_index_usartf0++];
0002ed 91e0 2491 	LDS  R30,_tx_rd_index_usartf0
0002ef 5fef      	SUBI R30,-LOW(1)
0002f0 93e0 2491 	STS  _tx_rd_index_usartf0,R30
0002f2 50e1      	SUBI R30,LOW(1)
0002f3 e0f0      	LDI  R31,0
0002f4 5be0      	SUBI R30,LOW(-_tx_buffer_usartf0)
0002f5 4dfb      	SBCI R31,HIGH(-_tx_buffer_usartf0)
0002f6 81e0      	LD   R30,Z
0002f7 93e0 0ba0 	STS  2976,R30
                 ; 0000 0324 #if TX_BUFFER_SIZE_USARTF0 != 256
                 ; 0000 0325    if (tx_rd_index_usartf0 == TX_BUFFER_SIZE_USARTF0) tx_rd_index_usartf0=0;
0002f9 91a0 2491 	LDS  R26,_tx_rd_index_usartf0
0002fb 34a0      	CPI  R26,LOW(0x40)
0002fc f419      	BRNE _0x18
0002fd e0e0      	LDI  R30,LOW(0)
0002fe 93e0 2491 	STS  _tx_rd_index_usartf0,R30
                 ; 0000 0326 #endif
                 ; 0000 0327    }
                 _0x18:
                 ; 0000 0328 }
                 _0x17:
000300 91e9      	LD   R30,Y+
000301 bfef      	OUT  SREG,R30
000302 91f9      	LD   R31,Y+
000303 91e9      	LD   R30,Y+
000304 91a9      	LD   R26,Y+
000305 9518      	RETI
                 ; .FEND
                 ;
                 ;// Write a character to the USARTF0 Transmitter buffer
                 ;// USARTF0 is used as the default output device by the 'putchar' function
                 ;#define _ALTERNATE_PUTCHAR_
                 ;
                 ;#pragma used+
                 ;void putchar(char c)
                 ; 0000 0330 {
                 _putchar:
                 ; .FSTART _putchar
                 ; 0000 0331 while (tx_counter_usartf0 == TX_BUFFER_SIZE_USARTF0);
000306 93aa      	ST   -Y,R26
                 ;	c -> Y+0
                 _0x19:
000307 91a0 2492 	LDS  R26,_tx_counter_usartf0
000309 34a0      	CPI  R26,LOW(0x40)
00030a f3e1      	BREQ _0x19
                 ; 0000 0332 #asm("cli")
00030b 94f8      	cli
                 ; 0000 0333 if (tx_counter_usartf0 || ((USARTF0.STATUS & USART_DREIF_bm)==0))
00030c 91e0 2492 	LDS  R30,_tx_counter_usartf0
00030e 30e0      	CPI  R30,0
00030f f421      	BRNE _0x1D
000310 91e0 0ba1 	LDS  R30,2977
000312 72e0      	ANDI R30,LOW(0x20)
000313 f4c1      	BRNE _0x1C
                 _0x1D:
                 ; 0000 0334    {
                 ; 0000 0335    tx_buffer_usartf0[tx_wr_index_usartf0++]=c;
000314 91e0 2490 	LDS  R30,_tx_wr_index_usartf0
000316 5fef      	SUBI R30,-LOW(1)
000317 93e0 2490 	STS  _tx_wr_index_usartf0,R30
000319 50e1      	SUBI R30,LOW(1)
00031a e0f0      	LDI  R31,0
00031b 5be0      	SUBI R30,LOW(-_tx_buffer_usartf0)
00031c 4dfb      	SBCI R31,HIGH(-_tx_buffer_usartf0)
00031d 81a8      	LD   R26,Y
00031e 83a0      	STD  Z+0,R26
                 ; 0000 0336 #if TX_BUFFER_SIZE_USARTF0 != 256
                 ; 0000 0337    if (tx_wr_index_usartf0 == TX_BUFFER_SIZE_USARTF0) tx_wr_index_usartf0=0;
00031f 91a0 2490 	LDS  R26,_tx_wr_index_usartf0
000321 34a0      	CPI  R26,LOW(0x40)
000322 f419      	BRNE _0x1F
000323 e0e0      	LDI  R30,LOW(0)
000324 93e0 2490 	STS  _tx_wr_index_usartf0,R30
                 ; 0000 0338 #endif
                 ; 0000 0339    ++tx_counter_usartf0;
                 _0x1F:
000326 91e0 2492 	LDS  R30,_tx_counter_usartf0
000328 5fef      	SUBI R30,-LOW(1)
000329 93e0 2492 	STS  _tx_counter_usartf0,R30
                 ; 0000 033A    }
                 ; 0000 033B else
00032b c003      	RJMP _0x20
                 _0x1C:
                 ; 0000 033C    USARTF0.DATA=c;
00032c 81e8      	LD   R30,Y
00032d 93e0 0ba0 	STS  2976,R30
                 ; 0000 033D #asm("sei")
                 _0x20:
00032f 9478      	sei
                 ; 0000 033E }
000330 9621      	ADIW R28,1
000331 9508      	RET
                 ; .FEND
                 ;#pragma used-
                 ;
                 ;
                 ;
                 ;// DACB initialization
                 ;void dacb_init(void)
                 ; 0000 0345 {
                 _dacb_init:
                 ; .FSTART _dacb_init
                 ; 0000 0346 // Operating mode: Single Channel (Ch0)
                 ; 0000 0347 // Channel 0 triggered by the event system: Off
                 ; 0000 0348 DACB.CTRLB=(DACB.CTRLB & (~(DAC_CHSEL_gm | DAC_CH0TRIG_bm | DAC_CH1TRIG_bm))) |
                 ; 0000 0349 	DAC_CHSEL_SINGLE_gc;
000332 91e0 0321 	LDS  R30,801
000334 79ec      	ANDI R30,LOW(0x9C)
000335 93e0 0321 	STS  801,R30
                 ; 0000 034A 
                 ; 0000 034B // Reference: AREF on PORTB
                 ; 0000 034C // Left adjust value: Off
                 ; 0000 034D DACB.CTRLC=(DACB.CTRLC & (~(DAC_REFSEL_gm | DAC_LEFTADJ_bm))) |
                 ; 0000 034E 	DAC_REFSEL_AREFB_gc;
000337 91e0 0322 	LDS  R30,802
000339 7ee6      	ANDI R30,LOW(0xE6)
00033a 61e8      	ORI  R30,LOW(0x18)
00033b 93e0 0322 	STS  802,R30
                 ; 0000 034F 
                 ; 0000 0350 // DACB is enabled
                 ; 0000 0351 // Low power mode: Off
                 ; 0000 0352 // Channel 0 output: On
                 ; 0000 0353 // Channel 1 output: Off
                 ; 0000 0354 // Internal output connected to the ADCB and Analog Comparator MUX-es: Off
                 ; 0000 0355 DACB.CTRLA=(DACB.CTRLA & (~(DAC_IDOEN_bm | DAC_CH0EN_bm | DAC_CH1EN_bm | DAC_LPMODE_bm))) |
                 ; 0000 0356 	DAC_CH0EN_bm | DAC_ENABLE_bm;
00033d 91e0 0320 	LDS  R30,800
00033f 7ee1      	ANDI R30,LOW(0xE1)
000340 60e5      	ORI  R30,LOW(0x5)
000341 93e0 0320 	STS  800,R30
                 ; 0000 0357 }
000343 9508      	RET
                 ; .FEND
                 ;
                 ;// Function used to write data to a DACB channel ch
                 ;void dacb_write(unsigned char ch, unsigned int data)
                 ; 0000 035B {
                 _dacb_write:
                 ; .FSTART _dacb_write
                 ; 0000 035C register unsigned char m=ch ? DAC_CH1DRE_bm : DAC_CH0DRE_bm;
                 ; 0000 035D // Wait for the channel data register to be ready for new data
                 ; 0000 035E while ((DACB.STATUS & m)==0);
000344 93ba      	ST   -Y,R27
000345 93aa      	ST   -Y,R26
000346 931a      	ST   -Y,R17
                 ;	ch -> Y+3
                 ;	data -> Y+1
                 ;	m -> R17
000347 81eb      	LDD  R30,Y+3
000348 30e0      	CPI  R30,0
000349 f011      	BREQ _0x21
00034a e0e2      	LDI  R30,LOW(2)
00034b c001      	RJMP _0x22
                 _0x21:
00034c e0e1      	LDI  R30,LOW(1)
                 _0x22:
00034d 2f1e      	MOV  R17,R30
                 _0x24:
00034e 91e0 0325 	LDS  R30,805
000350 23e1      	AND  R30,R17
000351 f3e1      	BREQ _0x24
                 ; 0000 035F // Write new data to the channel data register
                 ; 0000 0360 if (m==DAC_CH1DRE_bm) DACB.CH1DATA=data;
000352 3012      	CPI  R17,2
000353 f439      	BRNE _0x27
000354 81e9      	LDD  R30,Y+1
000355 81fa      	LDD  R31,Y+1+1
000356 93e0 033a 	STS  826,R30
000358 93f0 033b 	STS  826+1,R31
                 ; 0000 0361 else DACB.CH0DATA=data;
00035a c006      	RJMP _0x28
                 _0x27:
00035b 81e9      	LDD  R30,Y+1
00035c 81fa      	LDD  R31,Y+1+1
00035d 93e0 0338 	STS  824,R30
00035f 93f0 0339 	STS  824+1,R31
                 ; 0000 0362 }
                 _0x28:
000361 8118      	LDD  R17,Y+0
000362 9624      	ADIW R28,4
000363 9508      	RET
                 ; .FEND
                 ;// Disable a Timer/Counter type TC0
                 ;void tc0_disable(TC0_t *ptc)
                 ; 0000 0365 {
                 _tc0_disable:
                 ; .FSTART _tc0_disable
                 ; 0000 0366 // Timer/Counter off
                 ; 0000 0367 ptc->CTRLA=TC_CLKSEL_OFF_gc;
000364 93ba      	ST   -Y,R27
000365 93aa      	ST   -Y,R26
                 ;	*ptc -> Y+0
000366 81a8      	LD   R26,Y
000367 81b9      	LDD  R27,Y+1
000368 e0e0      	LDI  R30,LOW(0)
000369 93ec      	ST   X,R30
                 ; 0000 0368 // Issue a reset command
                 ; 0000 0369 ptc->CTRLFSET=TC_CMD_RESET_gc;
00036a 9619      	ADIW R26,9
00036b e0ec      	LDI  R30,LOW(12)
00036c 93ec      	ST   X,R30
                 ; 0000 036A }
00036d c071      	RJMP _0x2060003
                 ; .FEND
                 ;
                 ;// Timer/Counter TCC0 initialization
                 ;void tcc0_init(void)
                 ; 0000 036E {
                 _tcc0_init:
                 ; .FSTART _tcc0_init
                 ; 0000 036F unsigned char s;
                 ; 0000 0370 unsigned char n;
                 ; 0000 0371 
                 ; 0000 0372 // Note: The correct PORTC direction for the Compare Channels
                 ; 0000 0373 // outputs is configured in the ports_init function.
                 ; 0000 0374 
                 ; 0000 0375 // Save interrupts enabled/disabled state
                 ; 0000 0376 s=SREG;
00036e 931a      	ST   -Y,R17
00036f 930a      	ST   -Y,R16
                 ;	s -> R17
                 ;	n -> R16
000370 b71f      	IN   R17,63
                 ; 0000 0377 // Disable interrupts
                 ; 0000 0378 #asm("cli")
000371 94f8      	cli
                 ; 0000 0379 
                 ; 0000 037A // Disable and reset the timer/counter just to be sure
                 ; 0000 037B tc0_disable(&TCC0);
000372 e0a0      	LDI  R26,LOW(2048)
000373 e0b8      	LDI  R27,HIGH(2048)
000374 dfef      	RCALL _tc0_disable
                 ; 0000 037C // Clock source: ClkPer/1
                 ; 0000 037D TCC0.CTRLA=TC_CLKSEL_DIV1_gc;
000375 e0e1      	LDI  R30,LOW(1)
000376 93e0 0800 	STS  2048,R30
                 ; 0000 037E // Mode: Single Slope PWM Gen., Overflow Int./Event on BOTTOM
                 ; 0000 037F // Compare/Capture on channel A: On
                 ; 0000 0380 // Compare/Capture on channel B: On
                 ; 0000 0381 // Compare/Capture on channel C: On
                 ; 0000 0382 // Compare/Capture on channel D: Off
                 ; 0000 0383 TCC0.CTRLB=(0<<TC0_CCDEN_bp) | (1<<TC0_CCCEN_bp) | (1<<TC0_CCBEN_bp) | (1<<TC0_CCAEN_bp) |
                 ; 0000 0384 	TC_WGMODE_SS_gc;
000378 e7e3      	LDI  R30,LOW(115)
000379 93e0 0801 	STS  2049,R30
                 ; 0000 0385 // Capture event source: None
                 ; 0000 0386 // Capture event action: None
                 ; 0000 0387 TCC0.CTRLD=TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc;
00037b e0e0      	LDI  R30,LOW(0)
00037c 93e0 0803 	STS  2051,R30
                 ; 0000 0388 
                 ; 0000 0389 // Set Timer/Counter in Normal mode
                 ; 0000 038A TCC0.CTRLE=TC_BYTEM_NORMAL_gc;
00037e 93e0 0804 	STS  2052,R30
                 ; 0000 038B 
                 ; 0000 038C // Overflow interrupt: Disabled
                 ; 0000 038D // Error interrupt: Disabled
                 ; 0000 038E TCC0.INTCTRLA=TC_ERRINTLVL_OFF_gc | TC_OVFINTLVL_OFF_gc;
000380 93e0 0806 	STS  2054,R30
                 ; 0000 038F 
                 ; 0000 0390 // Compare/Capture channel A interrupt: Disabled
                 ; 0000 0391 // Compare/Capture channel B interrupt: Disabled
                 ; 0000 0392 // Compare/Capture channel C interrupt: Disabled
                 ; 0000 0393 // Compare/Capture channel D interrupt: Disabled
                 ; 0000 0394 TCC0.INTCTRLB=TC_CCDINTLVL_OFF_gc | TC_CCCINTLVL_OFF_gc | TC_CCBINTLVL_OFF_gc | TC_CCAINTLVL_OFF_gc;
000382 93e0 0807 	STS  2055,R30
                 ; 0000 0395 
                 ; 0000 0396 // High resolution extension: Off
                 ; 0000 0397 HIRESC.CTRLA&= ~HIRES_HREN0_bm;
000384 91e0 0890 	LDS  R30,2192
000386 7fee      	ANDI R30,0xFE
000387 93e0 0890 	STS  2192,R30
                 ; 0000 0398 
                 ; 0000 0399 // Advanced Waveform Extension initialization
                 ; 0000 039A // Optimize for speed
                 ; 0000 039B #pragma optsize-
                 ; 0000 039C // Disable locking the AWEX configuration registers just to be sure
                 ; 0000 039D n=MCU.AWEXLOCK & (~MCU_AWEXCLOCK_bm);
000389 91e0 0099 	LDS  R30,153
00038b 7fee      	ANDI R30,0xFE
00038c 2f0e      	MOV  R16,R30
                 ; 0000 039E CCP=CCP_IOREG_gc;
00038d ede8      	LDI  R30,LOW(216)
00038e bfe4      	OUT  0x34,R30
                 ; 0000 039F MCU.AWEXLOCK=n;
00038f 9300 0099 	STS  153,R16
                 ; 0000 03A0 // Restore optimization for size if needed
                 ; 0000 03A1 #pragma optsize_default
                 ; 0000 03A2 
                 ; 0000 03A3 // Pattern generation: Off
                 ; 0000 03A4 // Common waveform channel mode: Off
                 ; 0000 03A5 // Dead time insertion for compare channel A: Off
                 ; 0000 03A6 // Dead time insertion for compare channel B: Off
                 ; 0000 03A7 // Dead time insertion for compare channel C: Off
                 ; 0000 03A8 // Dead time insertion for compare channel D: Off
                 ; 0000 03A9 AWEXC.CTRL=(0<<AWEX_PGM_bp) | (0<<AWEX_CWCM_bp) | (0<<AWEX_DTICCDEN_bp) | (0<<AWEX_DTICCCEN_bp) |
                 ; 0000 03AA 	(0<<AWEX_DTICCBEN_bp) | (0<<AWEX_DTICCAEN_bp);
000391 e0e0      	LDI  R30,LOW(0)
000392 93e0 0880 	STS  2176,R30
                 ; 0000 03AB // Low side dead time duration [ClkPer cycles]
                 ; 0000 03AC AWEXC.DTLS=0;
000394 93e0 0888 	STS  2184,R30
                 ; 0000 03AD // High side dead time duration [ClkPer cycles]
                 ; 0000 03AE AWEXC.DTHS=0;
000396 93e0 0889 	STS  2185,R30
                 ; 0000 03AF // PORTC output register override
                 ; 0000 03B0 AWEXC.OUTOVEN=0b00000000;
000398 93e0 088c 	STS  2188,R30
                 ; 0000 03B1 
                 ; 0000 03B2 // Fault protection initialization
                 ; 0000 03B3 // Fault detection on OCD Break detection: On
                 ; 0000 03B4 // Fault detection restart mode: Latched Mode
                 ; 0000 03B5 // Fault detection action: None (Fault protection disabled)
                 ; 0000 03B6 AWEXC.FDCTRL=(AWEXC.FDCTRL & (~(AWEX_FDDBD_bm | AWEX_FDMODE_bm | AWEX_FDACT_gm))) |
                 ; 0000 03B7 	(0<<AWEX_FDDBD_bp) | (0<<AWEX_FDMODE_bp) | AWEX_FDACT_NONE_gc;
00039a 91e0 0883 	LDS  R30,2179
00039c 7ee8      	ANDI R30,LOW(0xE8)
00039d 93e0 0883 	STS  2179,R30
                 ; 0000 03B8 // Fault detect events:
                 ; 0000 03B9 // Event channel 0: Off
                 ; 0000 03BA // Event channel 1: Off
                 ; 0000 03BB // Event channel 2: Off
                 ; 0000 03BC // Event channel 3: Off
                 ; 0000 03BD // Event channel 4: Off
                 ; 0000 03BE // Event channel 5: Off
                 ; 0000 03BF // Event channel 6: Off
                 ; 0000 03C0 // Event channel 7: Off
                 ; 0000 03C1 AWEXC.FDEMASK=0b00000000;
00039f e0e0      	LDI  R30,LOW(0)
0003a0 93e0 0882 	STS  2178,R30
                 ; 0000 03C2 // Make sure the fault detect flag is cleared
                 ; 0000 03C3 AWEXC.STATUS|=AWEXC.STATUS & AWEX_FDF_bm;
0003a2 e8a4      	LDI  R26,LOW(2180)
0003a3 e0b8      	LDI  R27,HIGH(2180)
0003a4 2e0a      	MOV  R0,R26
0003a5 91ac      	LD   R26,X
0003a6 91e0 0884 	LDS  R30,2180
0003a8 70e4      	ANDI R30,LOW(0x4)
0003a9 2bea      	OR   R30,R26
0003aa 2da0      	MOV  R26,R0
0003ab 93ec      	ST   X,R30
                 ; 0000 03C4 
                 ; 0000 03C5 // Clear the interrupt flags
                 ; 0000 03C6 TCC0.INTFLAGS=TCC0.INTFLAGS;
0003ac 91e0 080c 	LDS  R30,2060
0003ae 93e0 080c 	STS  2060,R30
                 ; 0000 03C7 // Set Counter register
                 ; 0000 03C8 TCC0.CNT=0x0000;
0003b0 e0e0      	LDI  R30,LOW(0)
0003b1 e0f0      	LDI  R31,HIGH(0)
0003b2 93e0 0820 	STS  2080,R30
0003b4 93f0 0821 	STS  2080+1,R31
                 ; 0000 03C9 // Set Period register
                 ; 0000 03CA TCC0.PER=0x013F;
0003b6 e3ef      	LDI  R30,LOW(319)
0003b7 e0f1      	LDI  R31,HIGH(319)
0003b8 93e0 0826 	STS  2086,R30
0003ba 93f0 0827 	STS  2086+1,R31
                 ; 0000 03CB // Set channel A Compare/Capture register
                 ; 0000 03CC TCC0.CCA=0x0000;
0003bc e0e0      	LDI  R30,LOW(0)
0003bd e0f0      	LDI  R31,HIGH(0)
0003be 93e0 0828 	STS  2088,R30
0003c0 93f0 0829 	STS  2088+1,R31
                 ; 0000 03CD // Set channel B Compare/Capture register
                 ; 0000 03CE TCC0.CCB=0x0000;
0003c2 93e0 082a 	STS  2090,R30
0003c4 93f0 082b 	STS  2090+1,R31
                 ; 0000 03CF // Set channel C Compare/Capture register
                 ; 0000 03D0 TCC0.CCC=0x0000;
0003c6 93e0 082c 	STS  2092,R30
0003c8 93f0 082d 	STS  2092+1,R31
                 ; 0000 03D1 // Set channel D Compare/Capture register
                 ; 0000 03D2 TCC0.CCD=0x0000;
0003ca 93e0 082e 	STS  2094,R30
0003cc 93f0 082f 	STS  2094+1,R31
                 ; 0000 03D3 
                 ; 0000 03D4 // Restore interrupts enabled/disabled state
                 ; 0000 03D5 SREG=s;
0003ce bf1f      	OUT  0x3F,R17
                 ; 0000 03D6 }
                 _0x2060004:
0003cf 9109      	LD   R16,Y+
0003d0 9119      	LD   R17,Y+
0003d1 9508      	RET
                 ; .FEND
                 ;
                 ;
                 ;
                 ;// Function used to read the calibration byte from the
                 ;// signature row, specified by 'index'
                 ;#pragma optsize-
                 ;unsigned char read_calibration_byte(unsigned char index)
                 ; 0000 03DE {
                 _read_calibration_byte:
                 ; .FSTART _read_calibration_byte
                 ; 0000 03DF unsigned char r;
                 ; 0000 03E0 NVM.CMD=NVM_CMD_READ_CALIB_ROW_gc;
0003d2 93aa      	ST   -Y,R26
0003d3 931a      	ST   -Y,R17
                 ;	index -> Y+1
                 ;	r -> R17
0003d4 e0e2      	LDI  R30,LOW(2)
0003d5 93e0 01ca 	STS  458,R30
                 ; 0000 03E1 r=*((flash unsigned char*) index);
0003d7 81e9      	LDD  R30,Y+1
0003d8 e0f0      	LDI  R31,0
0003d9 9114      	LPM  R17,Z
                 ; 0000 03E2 // Clean up NVM command register
                 ; 0000 03E3 NVM.CMD=NVM_CMD_NO_OPERATION_gc;
0003da e0e0      	LDI  R30,LOW(0)
0003db 93e0 01ca 	STS  458,R30
                 ; 0000 03E4 return r;
0003dd 2fe1      	MOV  R30,R17
0003de 8118      	LDD  R17,Y+0
                 _0x2060003:
0003df 9622      	ADIW R28,2
0003e0 9508      	RET
                 ; 0000 03E5 }
                 ; .FEND
                 ;#pragma optsize_default
                 ;// ADCA initialization
                 ;void adca_init(void)
                 ; 0000 03E9 {
                 _adca_init:
                 ; .FSTART _adca_init
                 ; 0000 03EA // ADCA is enabled
                 ; 0000 03EB // Resolution: 12 Bits
                 ; 0000 03EC // Load the calibration value for 12 Bit resolution
                 ; 0000 03ED // from the signature row
                 ; 0000 03EE ADCA.CALL=read_calibration_byte(PROD_SIGNATURES_START+ADCACAL0_offset);
0003e1 e2a0      	LDI  R26,LOW(32)
0003e2 dfef      	RCALL _read_calibration_byte
0003e3 93e0 020c 	STS  524,R30
                 ; 0000 03EF ADCA.CALH=read_calibration_byte(PROD_SIGNATURES_START+ADCACAL1_offset);
0003e5 e2a1      	LDI  R26,LOW(33)
0003e6 dfeb      	RCALL _read_calibration_byte
0003e7 93e0 020d 	STS  525,R30
                 ; 0000 03F0 
                 ; 0000 03F1 // Free Running mode: Off
                 ; 0000 03F2 // Gain stage impedance mode: High-impedance sources
                 ; 0000 03F3 // Current consumption: No limit
                 ; 0000 03F4 // Conversion mode: Unsigned
                 ; 0000 03F5 ADCA.CTRLB=(0<<ADC_IMPMODE_bp) | ADC_CURRLIMIT_NO_gc | (0<<ADC_CONMODE_bp) | ADC_RESOLUTION_12BIT_gc;
0003e9 e0e0      	LDI  R30,LOW(0)
0003ea 93e0 0201 	STS  513,R30
                 ; 0000 03F6 
                 ; 0000 03F7 // Clock frequency: 2000.000 kHz
                 ; 0000 03F8 ADCA.PRESCALER=ADC_PRESCALER_DIV16_gc;
0003ec e0e2      	LDI  R30,LOW(2)
0003ed 93e0 0204 	STS  516,R30
                 ; 0000 03F9 
                 ; 0000 03FA // Reference: AREF pin on PORTA
                 ; 0000 03FB // Temperature reference: Off
                 ; 0000 03FC ADCA.REFCTRL=ADC_REFSEL_AREFA_gc | (0<<ADC_TEMPREF_bp) | (0<<ADC_BANDGAP_bp);
0003ef e2e0      	LDI  R30,LOW(32)
0003f0 93e0 0202 	STS  514,R30
                 ; 0000 03FD 
                 ; 0000 03FE // Initialize the ADC Compare register
                 ; 0000 03FF ADCA.CMPL=0x00;
0003f2 e0e0      	LDI  R30,LOW(0)
0003f3 93e0 0218 	STS  536,R30
                 ; 0000 0400 ADCA.CMPH=0x00;
0003f5 93e0 0219 	STS  537,R30
                 ; 0000 0401 
                 ; 0000 0402 // ADC channel 0 gain: 1
                 ; 0000 0403 // ADC channel 0 input mode: Single-ended positive input signal
                 ; 0000 0404 ADCA.CH0.CTRL=(0<<ADC_CH_START_bp) | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
0003f7 e0e1      	LDI  R30,LOW(1)
0003f8 93e0 0220 	STS  544,R30
                 ; 0000 0405 
                 ; 0000 0406 // ADC channel 0 positive input: ADC1 pin
                 ; 0000 0407 // ADC channel 0 negative input: GND
                 ; 0000 0408 ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN1_gc;
0003fa e0e8      	LDI  R30,LOW(8)
0003fb 93e0 0221 	STS  545,R30
                 ; 0000 0409 
                 ; 0000 040A // ADC channel 1 gain: 1
                 ; 0000 040B // ADC channel 1 input mode: Single-ended positive input signal
                 ; 0000 040C ADCA.CH1.CTRL=(0<<ADC_CH_START_bp) | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
0003fd e0e1      	LDI  R30,LOW(1)
0003fe 93e0 0228 	STS  552,R30
                 ; 0000 040D 
                 ; 0000 040E // ADC channel 1 positive input: ADC2 pin
                 ; 0000 040F // ADC channel 1 negative input: GND
                 ; 0000 0410 ADCA.CH1.MUXCTRL=ADC_CH_MUXPOS_PIN2_gc;
000400 e1e0      	LDI  R30,LOW(16)
000401 93e0 0229 	STS  553,R30
                 ; 0000 0411 
                 ; 0000 0412 // ADC channel 2 gain: 1
                 ; 0000 0413 // ADC channel 2 input mode: Single-ended positive input signal
                 ; 0000 0414 ADCA.CH2.CTRL=(0<<ADC_CH_START_bp) | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
000403 e0e1      	LDI  R30,LOW(1)
000404 93e0 0230 	STS  560,R30
                 ; 0000 0415 
                 ; 0000 0416 // ADC channel 2 positive input: ADC3 pin
                 ; 0000 0417 // ADC channel 2 negative input: GND
                 ; 0000 0418 ADCA.CH2.MUXCTRL=ADC_CH_MUXPOS_PIN3_gc;
000406 e1e8      	LDI  R30,LOW(24)
000407 93e0 0231 	STS  561,R30
                 ; 0000 0419 
                 ; 0000 041A // ADC channel 3 gain: 1
                 ; 0000 041B // ADC channel 3 input mode: Single-ended positive input signal
                 ; 0000 041C ADCA.CH3.CTRL=(0<<ADC_CH_START_bp) | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
000409 e0e1      	LDI  R30,LOW(1)
00040a 93e0 0238 	STS  568,R30
                 ; 0000 041D 
                 ; 0000 041E // ADC channel 3 positive input: ADC4 pin
                 ; 0000 041F // ADC channel 3 negative input: GND
                 ; 0000 0420 ADCA.CH3.MUXCTRL=ADC_CH_MUXPOS_PIN4_gc;
00040c e2e0      	LDI  R30,LOW(32)
00040d 93e0 0239 	STS  569,R30
                 ; 0000 0421 
                 ; 0000 0422 // AD conversion is started by software
                 ; 0000 0423 ADCA.EVCTRL=ADC_EVACT_NONE_gc;
00040f e0e0      	LDI  R30,LOW(0)
000410 93e0 0203 	STS  515,R30
                 ; 0000 0424 
                 ; 0000 0425 // Channel 0 interrupt: Disabled
                 ; 0000 0426 ADCA.CH0.INTCTRL=ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
000412 93e0 0222 	STS  546,R30
                 ; 0000 0427 // Channel 1 interrupt: Disabled
                 ; 0000 0428 ADCA.CH1.INTCTRL=ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
000414 93e0 022a 	STS  554,R30
                 ; 0000 0429 // Channel 2 interrupt: Disabled
                 ; 0000 042A ADCA.CH2.INTCTRL=ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
000416 93e0 0232 	STS  562,R30
                 ; 0000 042B // Channel 3 interrupt: Disabled
                 ; 0000 042C ADCA.CH3.INTCTRL=ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
000418 93e0 023a 	STS  570,R30
                 ; 0000 042D 
                 ; 0000 042E // Enable the ADC
                 ; 0000 042F ADCA.CTRLA|=ADC_ENABLE_bm;
00041a 91e0 0200 	LDS  R30,512
00041c 60e1      	ORI  R30,1
00041d 93e0 0200 	STS  512,R30
                 ; 0000 0430 // Insert a delay to allow the ADC common mode voltage to stabilize
                 ; 0000 0431 delay_us(2);
00041f c048      	RJMP _0x2060002
                 ; 0000 0432 }
                 ; .FEND
                 ;
                 ;// ADCA channel data read function using polled mode
                 ;unsigned int adca_read(unsigned char channel)
                 ; 0000 0436 {
                 _adca_read:
                 ; .FSTART _adca_read
                 ; 0000 0437 ADC_CH_t *pch=&ADCA.CH0+channel;
                 ; 0000 0438 unsigned int data;
                 ; 0000 0439 
                 ; 0000 043A // Start the AD conversion
                 ; 0000 043B pch->CTRL|= 1<<ADC_CH_START_bp;
000420 93aa      	ST   -Y,R26
000421 940e 06e0 	CALL __SAVELOCR4
                 ;	channel -> Y+4
                 ;	*pch -> R16,R17
                 ;	data -> R18,R19
000423 81ec      	LDD  R30,Y+4
000424 e0f0      	LDI  R31,0
000425 e2a0      	LDI  R26,LOW(544)
000426 e0b2      	LDI  R27,HIGH(544)
000427 940e 05a3 	CALL SUBOPT_0x1
                 ; 0000 043C // Wait for the AD conversion to complete
                 ; 0000 043D while ((pch->INTFLAGS & ADC_CH_CHIF_bm)==0);
                 _0x29:
000429 01f8      	MOVW R30,R16
00042a 81a3      	LDD  R26,Z+3
00042b 70a1      	ANDI R26,LOW(0x1)
00042c f3e1      	BREQ _0x29
                 ; 0000 043E // Clear the interrupt flag
                 ; 0000 043F pch->INTFLAGS=ADC_CH_CHIF_bm;
00042d c04b      	RJMP _0x2060001
                 ; 0000 0440 // Read the AD conversion result
                 ; 0000 0441 ((unsigned char *) &data)[0]=pch->RESL;
                 ; 0000 0442 ((unsigned char *) &data)[1]=pch->RESH;
                 ; 0000 0443 return data;
                 ; 0000 0444 }
                 ; .FEND
                 ;
                 ;// ADCA sweeped channel(s) data read function
                 ;// for software triggered mode
                 ;void adca_sweep_read(unsigned char nch, unsigned int *pdata)
                 ; 0000 0449 {
                 ; 0000 044A ADC_CH_t *pch=&ADCA.CH0;
                 ; 0000 044B unsigned char i,j,m;
                 ; 0000 044C 
                 ; 0000 044D // Sweep starts with channel 0
                 ; 0000 044E j=ADC_CH0START_bm;
                 ;	nch -> Y+8
                 ;	*pdata -> Y+6
                 ;	*pch -> R16,R17
                 ;	i -> R19
                 ;	j -> R18
                 ;	m -> R21
                 ; 0000 044F // Prepare the AD conversion start mask for the sweeped channel(s)
                 ; 0000 0450 m=0;
                 ; 0000 0451 i=0;
                 ; 0000 0452 do
                 ; 0000 0453   {
                 ; 0000 0454   m|=j;
                 ; 0000 0455   j<<=1;
                 ; 0000 0456   }
                 ; 0000 0457 while (++i<nch);
                 ; 0000 0458 // Ensure the interrupt flags are cleared
                 ; 0000 0459 ADCA.INTFLAGS=ADCA.INTFLAGS;
                 ; 0000 045A // Start the AD conversion for the sweeped channel(s)
                 ; 0000 045B ADCA.CTRLA=(ADCA.CTRLA & (ADC_DMASEL_gm | ADC_FLUSH_bm | ADC_ENABLE_bm)) | m;
                 ; 0000 045C // Read and store the AD conversion results for all the sweeped channels
                 ; 0000 045D for (i=0; i<nch; i++)
                 ; 0000 045E     {
                 ; 0000 045F     // Wait for the AD conversion to complete
                 ; 0000 0460     while ((pch->INTFLAGS & ADC_CH_CHIF_bm)==0);
                 ; 0000 0461     // Clear the interrupt flag
                 ; 0000 0462     pch->INTFLAGS=ADC_CH_CHIF_bm;
                 ; 0000 0463     // Read the AD conversion result
                 ; 0000 0464     ((unsigned char *) pdata)[0]=pch->RESL;
                 ; 0000 0465     ((unsigned char *) pdata)[1]=pch->RESH;
                 ; 0000 0466     pdata++;
                 ; 0000 0467     pch++;
                 ; 0000 0468     }
                 ; 0000 0469 }
                 ;
                 ;// ADCB initialization
                 ;void adcb_init(void)
                 ; 0000 046D {
                 _adcb_init:
                 ; .FSTART _adcb_init
                 ; 0000 046E // ADCB is enabled
                 ; 0000 046F // Resolution: 12 Bits
                 ; 0000 0470 // Load the calibration value for 12 Bit resolution
                 ; 0000 0471 // from the signature row
                 ; 0000 0472 ADCB.CALL=read_calibration_byte(PROD_SIGNATURES_START+ADCBCAL0_offset);
00042e e2a4      	LDI  R26,LOW(36)
00042f dfa2      	RCALL _read_calibration_byte
000430 93e0 024c 	STS  588,R30
                 ; 0000 0473 ADCB.CALH=read_calibration_byte(PROD_SIGNATURES_START+ADCBCAL1_offset);
000432 e2a5      	LDI  R26,LOW(37)
000433 df9e      	RCALL _read_calibration_byte
000434 93e0 024d 	STS  589,R30
                 ; 0000 0474 
                 ; 0000 0475 // Free Running mode: Off
                 ; 0000 0476 // Gain stage impedance mode: High-impedance sources
                 ; 0000 0477 // Current consumption: No limit
                 ; 0000 0478 // Conversion mode: Unsigned
                 ; 0000 0479 ADCB.CTRLB=(0<<ADC_IMPMODE_bp) | ADC_CURRLIMIT_NO_gc | (0<<ADC_CONMODE_bp) | ADC_RESOLUTION_12BIT_gc;
000436 e0e0      	LDI  R30,LOW(0)
000437 93e0 0241 	STS  577,R30
                 ; 0000 047A 
                 ; 0000 047B // Clock frequency: 2000.000 kHz
                 ; 0000 047C ADCB.PRESCALER=ADC_PRESCALER_DIV16_gc;
000439 e0e2      	LDI  R30,LOW(2)
00043a 93e0 0244 	STS  580,R30
                 ; 0000 047D 
                 ; 0000 047E // Reference: AREF pin on PORTA
                 ; 0000 047F // Temperature reference: On
                 ; 0000 0480 ADCB.REFCTRL=ADC_REFSEL_AREFA_gc | (1<<ADC_TEMPREF_bp) | (0<<ADC_BANDGAP_bp);
00043c e2e1      	LDI  R30,LOW(33)
00043d 93e0 0242 	STS  578,R30
                 ; 0000 0481 
                 ; 0000 0482 // Initialize the ADC Compare register
                 ; 0000 0483 ADCB.CMPL=0x00;
00043f e0e0      	LDI  R30,LOW(0)
000440 93e0 0258 	STS  600,R30
                 ; 0000 0484 ADCB.CMPH=0x00;
000442 93e0 0259 	STS  601,R30
                 ; 0000 0485 
                 ; 0000 0486 // ADC channel 0 gain: 1
                 ; 0000 0487 // ADC channel 0 input mode: Single-ended positive input signal
                 ; 0000 0488 ADCB.CH0.CTRL=(0<<ADC_CH_START_bp) | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
000444 e0e1      	LDI  R30,LOW(1)
000445 93e0 0260 	STS  608,R30
                 ; 0000 0489 
                 ; 0000 048A // ADC channel 0 positive input: ADC1 pin
                 ; 0000 048B // ADC channel 0 negative input: GND
                 ; 0000 048C ADCB.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN1_gc;
000447 e0e8      	LDI  R30,LOW(8)
000448 93e0 0261 	STS  609,R30
                 ; 0000 048D 
                 ; 0000 048E // ADC channel 1 gain: 1
                 ; 0000 048F // ADC channel 1 input mode: Single-ended positive input signal
                 ; 0000 0490 ADCB.CH1.CTRL=(0<<ADC_CH_START_bp) | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
00044a e0e1      	LDI  R30,LOW(1)
00044b 93e0 0268 	STS  616,R30
                 ; 0000 0491 
                 ; 0000 0492 // ADC channel 1 positive input: ADC3 pin
                 ; 0000 0493 // ADC channel 1 negative input: GND
                 ; 0000 0494 ADCB.CH1.MUXCTRL=ADC_CH_MUXPOS_PIN3_gc;
00044d e1e8      	LDI  R30,LOW(24)
00044e 93e0 0269 	STS  617,R30
                 ; 0000 0495 
                 ; 0000 0496 // ADC channel 2 gain: 1
                 ; 0000 0497 // ADC channel 2 input mode: Internal positive input signal
                 ; 0000 0498 ADCB.CH2.CTRL=(0<<ADC_CH_START_bp) | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
000450 e0e0      	LDI  R30,LOW(0)
000451 93e0 0270 	STS  624,R30
                 ; 0000 0499 
                 ; 0000 049A // ADC channel 2 positive input: Temp. Reference
                 ; 0000 049B // ADC channel 2 negative input: GND
                 ; 0000 049C ADCB.CH2.MUXCTRL=ADC_CH_MUXINT_TEMP_gc;
000453 93e0 0271 	STS  625,R30
                 ; 0000 049D 
                 ; 0000 049E // ADC channel 3 gain: 1
                 ; 0000 049F // ADC channel 3 input mode: Internal positive input signal
                 ; 0000 04A0 ADCB.CH3.CTRL=(0<<ADC_CH_START_bp) | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
000455 93e0 0278 	STS  632,R30
                 ; 0000 04A1 
                 ; 0000 04A2 // ADC channel 3 positive input: Temp. Reference
                 ; 0000 04A3 // ADC channel 3 negative input: GND
                 ; 0000 04A4 ADCB.CH3.MUXCTRL=ADC_CH_MUXINT_TEMP_gc;
000457 93e0 0279 	STS  633,R30
                 ; 0000 04A5 
                 ; 0000 04A6 // AD conversion is started by software
                 ; 0000 04A7 ADCB.EVCTRL=ADC_EVACT_NONE_gc;
000459 93e0 0243 	STS  579,R30
                 ; 0000 04A8 
                 ; 0000 04A9 // Channel 0 interrupt: Disabled
                 ; 0000 04AA ADCB.CH0.INTCTRL=ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
00045b 93e0 0262 	STS  610,R30
                 ; 0000 04AB // Channel 1 interrupt: Disabled
                 ; 0000 04AC ADCB.CH1.INTCTRL=ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
00045d 93e0 026a 	STS  618,R30
                 ; 0000 04AD // Channel 2 interrupt: Disabled
                 ; 0000 04AE ADCB.CH2.INTCTRL=ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
00045f 93e0 0272 	STS  626,R30
                 ; 0000 04AF // Channel 3 interrupt: Disabled
                 ; 0000 04B0 ADCB.CH3.INTCTRL=ADC_CH_INTMODE_COMPLETE_gc | ADC_CH_INTLVL_OFF_gc;
000461 93e0 027a 	STS  634,R30
                 ; 0000 04B1 
                 ; 0000 04B2 // Enable the ADC
                 ; 0000 04B3 ADCB.CTRLA|=ADC_ENABLE_bm;
000463 91e0 0240 	LDS  R30,576
000465 60e1      	ORI  R30,1
000466 93e0 0240 	STS  576,R30
                 ; 0000 04B4 // Insert a delay to allow the ADC common mode voltage to stabilize
                 ; 0000 04B5 delay_us(2);
                 _0x2060002:
                +
000468 e185     +LDI R24 , LOW ( 21 )
                +__DELAY_USB_LOOP :
000469 958a     +DEC R24
00046a f7f1     +BRNE __DELAY_USB_LOOP
                 	__DELAY_USB 21
                 ; 0000 04B6 }
00046b 9508      	RET
                 ; .FEND
                 ;
                 ;// ADCB channel data read function using polled mode
                 ;unsigned int adcb_read(unsigned char channel)
                 ; 0000 04BA {
                 _adcb_read:
                 ; .FSTART _adcb_read
                 ; 0000 04BB ADC_CH_t *pch=&ADCB.CH0+channel;
                 ; 0000 04BC unsigned int data;
                 ; 0000 04BD 
                 ; 0000 04BE // Start the AD conversion
                 ; 0000 04BF pch->CTRL|= 1<<ADC_CH_START_bp;
00046c 93aa      	ST   -Y,R26
00046d 940e 06e0 	CALL __SAVELOCR4
                 ;	channel -> Y+4
                 ;	*pch -> R16,R17
                 ;	data -> R18,R19
00046f 81ec      	LDD  R30,Y+4
000470 e0f0      	LDI  R31,0
000471 e6a0      	LDI  R26,LOW(608)
000472 e0b2      	LDI  R27,HIGH(608)
000473 940e 05a3 	CALL SUBOPT_0x1
                 ; 0000 04C0 // Wait for the AD conversion to complete
                 ; 0000 04C1 while ((pch->INTFLAGS & ADC_CH_CHIF_bm)==0);
                 _0x35:
000475 01f8      	MOVW R30,R16
000476 81a3      	LDD  R26,Z+3
000477 70a1      	ANDI R26,LOW(0x1)
000478 f3e1      	BREQ _0x35
                 ; 0000 04C2 // Clear the interrupt flag
                 ; 0000 04C3 pch->INTFLAGS=ADC_CH_CHIF_bm;
                 _0x2060001:
000479 01d8      	MOVW R26,R16
00047a 9613      	ADIW R26,3
00047b e0e1      	LDI  R30,LOW(1)
00047c 93ec      	ST   X,R30
                 ; 0000 04C4 // Read the AD conversion result
                 ; 0000 04C5 ((unsigned char *) &data)[0]=pch->RESL;
00047d 01f8      	MOVW R30,R16
00047e 8124      	LDD  R18,Z+4
                 ; 0000 04C6 ((unsigned char *) &data)[1]=pch->RESH;
00047f 8135      	LDD  R19,Z+5
                 ; 0000 04C7 return data;
000480 01f9      	MOVW R30,R18
000481 940e 06e7 	CALL __LOADLOCR4
000483 9625      	ADIW R28,5
000484 9508      	RET
                 ; 0000 04C8 }
                 ; .FEND
                 ;
                 ;// ADCB sweeped channel(s) data read function
                 ;// for software triggered mode
                 ;void adcb_sweep_read(unsigned char nch, unsigned int *pdata)
                 ; 0000 04CD {
                 ; 0000 04CE ADC_CH_t *pch=&ADCB.CH0;
                 ; 0000 04CF unsigned char i,j,m;
                 ; 0000 04D0 
                 ; 0000 04D1 // Sweep starts with channel 0
                 ; 0000 04D2 j=ADC_CH0START_bm;
                 ;	nch -> Y+8
                 ;	*pdata -> Y+6
                 ;	*pch -> R16,R17
                 ;	i -> R19
                 ;	j -> R18
                 ;	m -> R21
                 ; 0000 04D3 // Prepare the AD conversion start mask for the sweeped channel(s)
                 ; 0000 04D4 m=0;
                 ; 0000 04D5 i=0;
                 ; 0000 04D6 do
                 ; 0000 04D7   {
                 ; 0000 04D8   m|=j;
                 ; 0000 04D9   j<<=1;
                 ; 0000 04DA   }
                 ; 0000 04DB while (++i<nch);
                 ; 0000 04DC // Ensure the interrupt flags are cleared
                 ; 0000 04DD ADCB.INTFLAGS=ADCB.INTFLAGS;
                 ; 0000 04DE // Start the AD conversion for the sweeped channel(s)
                 ; 0000 04DF ADCB.CTRLA=(ADCB.CTRLA & (ADC_DMASEL_gm | ADC_FLUSH_bm | ADC_ENABLE_bm)) | m;
                 ; 0000 04E0 // Read and store the AD conversion results for all the sweeped channels
                 ; 0000 04E1 for (i=0; i<nch; i++)
                 ; 0000 04E2     {
                 ; 0000 04E3     // Wait for the AD conversion to complete
                 ; 0000 04E4     while ((pch->INTFLAGS & ADC_CH_CHIF_bm)==0);
                 ; 0000 04E5     // Clear the interrupt flag
                 ; 0000 04E6     pch->INTFLAGS=ADC_CH_CHIF_bm;
                 ; 0000 04E7     // Read the AD conversion result
                 ; 0000 04E8     ((unsigned char *) pdata)[0]=pch->RESL;
                 ; 0000 04E9     ((unsigned char *) pdata)[1]=pch->RESH;
                 ; 0000 04EA     pdata++;
                 ; 0000 04EB     pch++;
                 ; 0000 04EC     }
                 ; 0000 04ED }
                 ;
                 ;void main(void)
                 ; 0000 04F0 {
                 _main:
                 ; .FSTART _main
                 ; 0000 04F1 // Declare your local variables here
                 ; 0000 04F2 unsigned char n;
                 ; 0000 04F3 int i;
                 ; 0000 04F4 unsigned int ADCA_data,ai;
                 ; 0000 04F5 unsigned char send_data[14];
                 ; 0000 04F6 unsigned char data_DIG;
                 ; 0000 04F7 
                 ; 0000 04F8 // Interrupt system initialization
                 ; 0000 04F9 // Optimize for speed
                 ; 0000 04FA #pragma optsize-
                 ; 0000 04FB // Make sure the interrupts are disabled
                 ; 0000 04FC #asm("cli")
000485 9760      	SBIW R28,16
                 ;	n -> R17
                 ;	i -> R18,R19
                 ;	ADCA_data -> R20,R21
                 ;	ai -> Y+14
                 ;	send_data -> Y+0
                 ;	data_DIG -> R16
000486 94f8      	cli
                 ; 0000 04FD // Low level interrupt: Off
                 ; 0000 04FE // Round-robin scheduling for low level interrupt: Off
                 ; 0000 04FF // Medium level interrupt: On
                 ; 0000 0500 // High level interrupt: On
                 ; 0000 0501 // The interrupt vectors will be placed at the start of the Application FLASH section
                 ; 0000 0502 n=(PMIC.CTRL & (~(PMIC_RREN_bm | PMIC_IVSEL_bm | PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm))) |
                 ; 0000 0503     PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
000487 91e0 00a2 	LDS  R30,162
000489 73e8      	ANDI R30,LOW(0x38)
00048a 60e6      	ORI  R30,LOW(0x6)
00048b 2f1e      	MOV  R17,R30
                 ; 0000 0504 CCP=CCP_IOREG_gc;
00048c ede8      	LDI  R30,LOW(216)
00048d bfe4      	OUT  0x34,R30
                 ; 0000 0505 PMIC.CTRL=n;
00048e 9310 00a2 	STS  162,R17
                 ; 0000 0506 // Set the default priority for round-robin scheduling
                 ; 0000 0507 PMIC.INTPRI=0x00;
000490 e0e0      	LDI  R30,LOW(0)
000491 93e0 00a1 	STS  161,R30
                 ; 0000 0508 // Restore optimization for size if needed
                 ; 0000 0509 #pragma optsize_default
                 ; 0000 050A 
                 ; 0000 050B // System clocks initialization
                 ; 0000 050C system_clocks_init();
000493 dcab      	RCALL _system_clocks_init
                 ; 0000 050D 
                 ; 0000 050E // Event system initialization
                 ; 0000 050F event_system_init();
000494 dcd9      	RCALL _event_system_init
                 ; 0000 0510 
                 ; 0000 0511 // Ports initialization
                 ; 0000 0512 ports_init();
000495 dd10      	RCALL _ports_init
                 ; 0000 0513 
                 ; 0000 0514 // Virtual Ports initialization
                 ; 0000 0515 vports_init();
000496 dde2      	RCALL _vports_init
                 ; 0000 0516 
                 ; 0000 0517 // USARTF0 initialization
                 ; 0000 0518 usartf0_init();
000497 dde8      	RCALL _usartf0_init
                 ; 0000 0519 
                 ; 0000 051A dacb_init();
000498 de99      	RCALL _dacb_init
                 ; 0000 051B 
                 ; 0000 051C tcc0_init();
000499 ded4      	RCALL _tcc0_init
                 ; 0000 051D 
                 ; 0000 051E adca_init();
00049a df46      	RCALL _adca_init
                 ; 0000 051F adcb_init();
00049b df92      	RCALL _adcb_init
                 ; 0000 0520 
                 ; 0000 0521 // Globally enable interrupts
                 ; 0000 0522 #asm("sei")
00049c 9478      	sei
                 ; 0000 0523 
                 ; 0000 0524 while (1)
                 _0x41:
                 ; 0000 0525       {
                 ; 0000 0526            if(flag)
00049d 2c06      	MOV  R0,R6
00049e 2807      	OR   R0,R7
00049f f409      	BRNE PC+2
0004a0 c0f9      	RJMP _0x44
                 ; 0000 0527            {
                 ; 0000 0528            flag=0;
0004a1 2466      	CLR  R6
0004a2 2477      	CLR  R7
                 ; 0000 0529            DAC_data = (requ_buffer[1]*256)+requ_buffer[2];//dac init
                +
0004a3 91a0 2401+LDS R26 , _requ_buffer + ( 1 )
                 	__GETB2MN _requ_buffer,1
0004a5 940e 05ad 	CALL SUBOPT_0x2
                +
0004a7 91e0 2402+LDS R30 , _requ_buffer + ( 2 )
                 	__GETB1MN _requ_buffer,2
0004a9 e0f0      	LDI  R31,0
0004aa 0fea      	ADD  R30,R26
0004ab 1ffb      	ADC  R31,R27
0004ac 016f      	MOVW R12,R30
                 ; 0000 052A 
                 ; 0000 052B            for(i=0;i<=11;i++)
                +
0004ad e020     +LDI R18 , LOW ( 0 )
0004ae e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x46:
                +
0004af 302c     +CPI R18 , LOW ( 12 )
0004b0 e0e0     +LDI R30 , HIGH ( 12 )
0004b1 073e     +CPC R19 , R30
                 	__CPWRN 18,19,12
0004b2 f44c      	BRGE _0x47
                 ; 0000 052C            putchar(requ_buffer[i]);
0004b3 e0a0      	LDI  R26,LOW(_requ_buffer)
0004b4 e2b4      	LDI  R27,HIGH(_requ_buffer)
0004b5 0fa2      	ADD  R26,R18
0004b6 1fb3      	ADC  R27,R19
0004b7 91ac      	LD   R26,X
0004b8 de4d      	RCALL _putchar
                +
0004b9 5f2f     +SUBI R18 , LOW ( - 1 )
0004ba 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
0004bb cff3      	RJMP _0x46
                 _0x47:
                 ; 0000 052E dacb_write(0,DAC_data);
0004bc e0e0      	LDI  R30,LOW(0)
0004bd 93ea      	ST   -Y,R30
0004be 01d6      	MOVW R26,R12
0004bf de84      	RCALL _dacb_write
                 ; 0000 052F 
                 ; 0000 0530            TCC0.CCA = ((requ_buffer[3]*256)+requ_buffer[4])/12.84;//PWM A init
                +
0004c0 91a0 2403+LDS R26 , _requ_buffer + ( 3 )
                 	__GETB2MN _requ_buffer,3
0004c2 940e 05ad 	CALL SUBOPT_0x2
                +
0004c4 91e0 2404+LDS R30 , _requ_buffer + ( 4 )
                 	__GETB1MN _requ_buffer,4
0004c6 940e 05b4 	CALL SUBOPT_0x3
0004c8 e2a8      	LDI  R26,LOW(2088)
0004c9 e0b8      	LDI  R27,HIGH(2088)
0004ca 940e 05c4 	CALL SUBOPT_0x4
                 ; 0000 0531            TCC0.CCB = ((requ_buffer[5]*256)+requ_buffer[6])/12.84;//PWM B init
                +
0004cc 91a0 2405+LDS R26 , _requ_buffer + ( 5 )
                 	__GETB2MN _requ_buffer,5
0004ce 940e 05ad 	CALL SUBOPT_0x2
                +
0004d0 91e0 2406+LDS R30 , _requ_buffer + ( 6 )
                 	__GETB1MN _requ_buffer,6
0004d2 940e 05b4 	CALL SUBOPT_0x3
0004d4 e2aa      	LDI  R26,LOW(2090)
0004d5 e0b8      	LDI  R27,HIGH(2090)
0004d6 940e 05c4 	CALL SUBOPT_0x4
                 ; 0000 0532            TCC0.CCC = ((requ_buffer[7]*256)+requ_buffer[8])/12.84;//PWM C init
                +
0004d8 91a0 2407+LDS R26 , _requ_buffer + ( 7 )
                 	__GETB2MN _requ_buffer,7
0004da 940e 05ad 	CALL SUBOPT_0x2
                +
0004dc 91e0 2408+LDS R30 , _requ_buffer + ( 8 )
                 	__GETB1MN _requ_buffer,8
0004de 940e 05b4 	CALL SUBOPT_0x3
0004e0 e2ac      	LDI  R26,LOW(2092)
0004e1 e0b8      	LDI  R27,HIGH(2092)
0004e2 940e 05c4 	CALL SUBOPT_0x4
                 ; 0000 0533            PORTE.OUT = ((requ_buffer[9]<<4)&0xF0)|((requ_buffer[10]>>4&0X0F));
                +
0004e4 91e0 2409+LDS R30 , _requ_buffer + ( 9 )
                 	__GETB1MN _requ_buffer,9
0004e6 95e2      	SWAP R30
0004e7 7fe0      	ANDI R30,LOW(0xF0)
0004e8 2fae      	MOV  R26,R30
                +
0004e9 91e0 240a+LDS R30 , _requ_buffer + ( 10 )
                 	__GETB1MN _requ_buffer,10
0004eb 95e2      	SWAP R30
0004ec 70ef      	ANDI R30,LOW(0xF)
0004ed 2bea      	OR   R30,R26
0004ee 93e0 0684 	STS  1668,R30
                 ; 0000 0534            if(requ_buffer[10]&0X01)
                +
0004f0 91e0 240a+LDS R30 , _requ_buffer + ( 10 )
                 	__GETB1MN _requ_buffer,10
0004f2 70e1      	ANDI R30,LOW(0x1)
0004f3 f021      	BREQ _0x48
                 ; 0000 0535            PORTD.OUTSET = 0X10;
0004f4 e1e0      	LDI  R30,LOW(16)
0004f5 93e0 0665 	STS  1637,R30
                 ; 0000 0536            else
0004f7 c003      	RJMP _0x49
                 _0x48:
                 ; 0000 0537            PORTD.OUTCLR = 0X10;
0004f8 e1e0      	LDI  R30,LOW(16)
0004f9 93e0 0666 	STS  1638,R30
                 ; 0000 0538            if(requ_buffer[10]&0X02)
                 _0x49:
                +
0004fb 91e0 240a+LDS R30 , _requ_buffer + ( 10 )
                 	__GETB1MN _requ_buffer,10
0004fd 70e2      	ANDI R30,LOW(0x2)
0004fe f021      	BREQ _0x4A
                 ; 0000 0539            PORTD.OUTSET = 0X20;
0004ff e2e0      	LDI  R30,LOW(32)
000500 93e0 0665 	STS  1637,R30
                 ; 0000 053A            else
000502 c003      	RJMP _0x4B
                 _0x4A:
                 ; 0000 053B            PORTD.OUTCLR = 0X20;
000503 e2e0      	LDI  R30,LOW(32)
000504 93e0 0666 	STS  1638,R30
                 ; 0000 053C            if(requ_buffer[10]&0X04)
                 _0x4B:
                +
000506 91e0 240a+LDS R30 , _requ_buffer + ( 10 )
                 	__GETB1MN _requ_buffer,10
000508 70e4      	ANDI R30,LOW(0x4)
000509 f021      	BREQ _0x4C
                 ; 0000 053D            PORTD.OUTSET = 0X40;
00050a e4e0      	LDI  R30,LOW(64)
00050b 93e0 0665 	STS  1637,R30
                 ; 0000 053E            else
00050d c003      	RJMP _0x4D
                 _0x4C:
                 ; 0000 053F            PORTD.OUTCLR = 0X40;
00050e e4e0      	LDI  R30,LOW(64)
00050f 93e0 0666 	STS  1638,R30
                 ; 0000 0540            if(requ_buffer[10]&0X08)
                 _0x4D:
                +
000511 91e0 240a+LDS R30 , _requ_buffer + ( 10 )
                 	__GETB1MN _requ_buffer,10
000513 70e8      	ANDI R30,LOW(0x8)
000514 f021      	BREQ _0x4E
                 ; 0000 0541            PORTD.OUTSET = 0X80;
000515 e8e0      	LDI  R30,LOW(128)
000516 93e0 0665 	STS  1637,R30
                 ; 0000 0542            else
000518 c003      	RJMP _0x4F
                 _0x4E:
                 ; 0000 0543            PORTD.OUTCLR = 0X80;
000519 e8e0      	LDI  R30,LOW(128)
00051a 93e0 0666 	STS  1638,R30
                 ; 0000 0544 
                 ; 0000 0545 
                 ; 0000 0546            for(i=0x01;i<=0x08;i=i*2)
                 _0x4F:
                +
00051c e021     +LDI R18 , LOW ( 1 )
00051d e030     +LDI R19 , HIGH ( 1 )
                 	__GETWRN 18,19,1
                 _0x51:
                +
00051e 3029     +CPI R18 , LOW ( 9 )
00051f e0e0     +LDI R30 , HIGH ( 9 )
000520 073e     +CPC R19 , R30
                 	__CPWRN 18,19,9
000521 f4b4      	BRGE _0x52
                 ; 0000 0547             {
                 ; 0000 0548            if(requ_buffer[10]&i)
                +
000522 91a0 240a+LDS R26 , _requ_buffer + ( 10 )
                 	__GETB2MN _requ_buffer,10
000524 01f9      	MOVW R30,R18
000525 e0b0      	LDI  R27,0
000526 23ea      	AND  R30,R26
000527 23fb      	AND  R31,R27
000528 9730      	SBIW R30,0
000529 f031      	BREQ _0x53
                 ; 0000 0549            PORTD.OUTSET = i*16;
00052a e1a0      	LDI  R26,LOW(16)
00052b 022a      	MULS R18,R26
00052c 01f0      	MOVW R30,R0
00052d 93e0 0665 	STS  1637,R30
                 ; 0000 054A            else
00052f c005      	RJMP _0x54
                 _0x53:
                 ; 0000 054B            PORTD.OUTCLR = i*16;
000530 e1a0      	LDI  R26,LOW(16)
000531 022a      	MULS R18,R26
000532 01f0      	MOVW R30,R0
000533 93e0 0666 	STS  1638,R30
                 ; 0000 054C             }
                 _0x54:
000535 0f22      	LSL  R18
000536 1f33      	ROL  R19
000537 cfe6      	RJMP _0x51
                 _0x52:
                 ; 0000 054D 
                 ; 0000 054E            PORTD.OUT |= ((requ_buffer[10]<<4)&0xF0);
000538 e6a4      	LDI  R26,LOW(1636)
000539 e0b6      	LDI  R27,HIGH(1636)
00053a 2e0a      	MOV  R0,R26
00053b 91ac      	LD   R26,X
                +
00053c 91e0 240a+LDS R30 , _requ_buffer + ( 10 )
                 	__GETB1MN _requ_buffer,10
00053e 95e2      	SWAP R30
00053f 7fe0      	ANDI R30,LOW(0xF0)
000540 2bea      	OR   R30,R26
000541 2da0      	MOV  R26,R0
000542 93ec      	ST   X,R30
                 ; 0000 054F //            PORTD.OUT = (0xFF);
                 ; 0000 0550 
                 ; 0000 0551 
                 ; 0000 0552 
                 ; 0000 0553            putchar(0xCC);
000543 ecac      	LDI  R26,LOW(204)
000544 ddc1      	RCALL _putchar
                 ; 0000 0554            ADCA_data = adca_read(0);
000545 e0a0      	LDI  R26,LOW(0)
000546 ded9      	RCALL _adca_read
000547 01af      	MOVW R20,R30
                 ; 0000 0555            send_data[0] = ADCA_data>>8 ;
                +
000548 8358     +STD Y + 0 , R21
                 	__PUTBSR 21,0
                 ; 0000 0556            send_data[1] = ADCA_data ;
000549 01fe      	MOVW R30,R28
00054a 9631      	ADIW R30,1
00054b 8340      	ST   Z,R20
                 ; 0000 0557 
                 ; 0000 0558            ADCA_data = adca_read(1);
00054c e0a1      	LDI  R26,LOW(1)
00054d ded2      	RCALL _adca_read
00054e 01af      	MOVW R20,R30
                 ; 0000 0559            send_data[2] = ADCA_data>>8 ;
                +
00054f 835a     +STD Y + 2 , R21
                 	__PUTBSR 21,2
                 ; 0000 055A            send_data[3] = ADCA_data ;
000550 01fe      	MOVW R30,R28
000551 9633      	ADIW R30,3
000552 8340      	ST   Z,R20
                 ; 0000 055B 
                 ; 0000 055C            ADCA_data = adca_read(2);
000553 e0a2      	LDI  R26,LOW(2)
000554 decb      	RCALL _adca_read
000555 01af      	MOVW R20,R30
                 ; 0000 055D            send_data[4] = ADCA_data>>8 ;
                +
000556 835c     +STD Y + 4 , R21
                 	__PUTBSR 21,4
                 ; 0000 055E            send_data[5] = ADCA_data ;
000557 01fe      	MOVW R30,R28
000558 9635      	ADIW R30,5
000559 8340      	ST   Z,R20
                 ; 0000 055F 
                 ; 0000 0560            ADCA_data = adca_read(3);
00055a e0a3      	LDI  R26,LOW(3)
00055b dec4      	RCALL _adca_read
00055c 01af      	MOVW R20,R30
                 ; 0000 0561            send_data[6] = ADCA_data>>8 ;
                +
00055d 835e     +STD Y + 6 , R21
                 	__PUTBSR 21,6
                 ; 0000 0562            send_data[7] = ADCA_data ;
00055e 01fe      	MOVW R30,R28
00055f 9637      	ADIW R30,7
000560 8340      	ST   Z,R20
                 ; 0000 0563 
                 ; 0000 0564            ADCA_data = adcb_read(0);
000561 e0a0      	LDI  R26,LOW(0)
000562 df09      	RCALL _adcb_read
000563 01af      	MOVW R20,R30
                 ; 0000 0565            send_data[8] = ADCA_data>>8 ;
                +
000564 8758     +STD Y + 8 , R21
                 	__PUTBSR 21,8
                 ; 0000 0566            send_data[9] = ADCA_data ;
000565 01fe      	MOVW R30,R28
000566 9639      	ADIW R30,9
000567 8340      	ST   Z,R20
                 ; 0000 0567 
                 ; 0000 0568            ADCA_data = adcb_read(1);
000568 e0a1      	LDI  R26,LOW(1)
000569 df02      	RCALL _adcb_read
00056a 01af      	MOVW R20,R30
                 ; 0000 0569            send_data[10] = ADCA_data>>8 ;
                +
00056b 875a     +STD Y + 10 , R21
                 	__PUTBSR 21,10
                 ; 0000 056A            send_data[11] = ADCA_data ;
00056c 01fe      	MOVW R30,R28
00056d 963b      	ADIW R30,11
00056e 8340      	ST   Z,R20
                 ; 0000 056B            //output ports
                 ; 0000 056C            send_data[12] = ((PORTB.IN&0XF0)>>4);
00056f 91e0 0628 	LDS  R30,1576
000571 7fe0      	ANDI R30,LOW(0xF0)
000572 e0f0      	LDI  R31,0
000573 940e 06b5 	CALL __ASRW4
000575 87ec      	STD  Y+12,R30
                 ; 0000 056D            send_data[13] = (PORTC.IN&0XF0);
000576 91e0 0648 	LDS  R30,1608
000578 7fe0      	ANDI R30,LOW(0xF0)
000579 87ed      	STD  Y+13,R30
                 ; 0000 056E            send_data[13] |= (PORTD.IN&0X0F);
00057a 01fe      	MOVW R30,R28
00057b 963d      	ADIW R30,13
00057c 010f      	MOVW R0,R30
00057d 81a0      	LD   R26,Z
00057e 91e0 0668 	LDS  R30,1640
000580 70ef      	ANDI R30,LOW(0xF)
000581 2bea      	OR   R30,R26
000582 01d0      	MOVW R26,R0
000583 93ec      	ST   X,R30
                 ; 0000 056F 
                 ; 0000 0570            for(ai=0;ai<=13;ai++)
000584 e0e0      	LDI  R30,LOW(0)
000585 87ee      	STD  Y+14,R30
000586 87ef      	STD  Y+14+1,R30
                 _0x56:
000587 85ae      	LDD  R26,Y+14
000588 85bf      	LDD  R27,Y+14+1
000589 971e      	SBIW R26,14
00058a f468      	BRSH _0x57
                 ; 0000 0571            {
                 ; 0000 0572             putchar(send_data[ai]);
00058b 85ee      	LDD  R30,Y+14
00058c 85ff      	LDD  R31,Y+14+1
00058d 01de      	MOVW R26,R28
00058e 0fae      	ADD  R26,R30
00058f 1fbf      	ADC  R27,R31
000590 91ac      	LD   R26,X
000591 dd74      	RCALL _putchar
                 ; 0000 0573            }
000592 85ee      	LDD  R30,Y+14
000593 85ff      	LDD  R31,Y+14+1
000594 9631      	ADIW R30,1
000595 87ee      	STD  Y+14,R30
000596 87ff      	STD  Y+14+1,R31
000597 cfef      	RJMP _0x56
                 _0x57:
                 ; 0000 0574 
                 ; 0000 0575            putchar(0xDD);
000598 edad      	LDI  R26,LOW(221)
000599 dd6c      	RCALL _putchar
                 ; 0000 0576               }
                 ; 0000 0577       }
                 _0x44:
00059a cf02      	RJMP _0x41
                 ; 0000 0578 }
                 _0x58:
00059b cfff      	RJMP _0x58
                 ; .FEND
                 
                 	.CSEG
                 
                 	.CSEG
                 
                 	.CSEG
                 
                 	.DSEG
                 _requ_buffer:
002400           	.BYTE 0xE
                 _rx_buffer_usartf0:
00240e           	.BYTE 0x40
                 _rx_rd_index_usartf0:
00244e           	.BYTE 0x1
                 _rx_counter_usartf0:
00244f           	.BYTE 0x1
                 _tx_buffer_usartf0:
002450           	.BYTE 0x40
                 _tx_wr_index_usartf0:
002490           	.BYTE 0x1
                 _tx_rd_index_usartf0:
002491           	.BYTE 0x1
                 _tx_counter_usartf0:
002492           	.BYTE 0x1
                 
                 	.CSEG
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x0:
00059c 50e0      	SUBI R30,LOW(-_requ_buffer)
00059d 4dfc      	SBCI R31,HIGH(-_requ_buffer)
00059e 8300      	ST   Z,R16
00059f 01f4      	MOVW R30,R8
0005a0 9631      	ADIW R30,1
0005a1 014f      	MOVW R8,R30
0005a2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x1:
0005a3 940e 06ae 	CALL __LSLW3
0005a5 0fea      	ADD  R30,R26
0005a6 1ffb      	ADC  R31,R27
0005a7 018f      	MOVW R16,R30
0005a8 01d8      	MOVW R26,R16
0005a9 91ec      	LD   R30,X
0005aa 68e0      	ORI  R30,0x80
0005ab 93ec      	ST   X,R30
0005ac 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x2:
0005ad e0b0      	LDI  R27,0
0005ae e0e0      	LDI  R30,LOW(256)
0005af e0f1      	LDI  R31,HIGH(256)
0005b0 940e 06cb 	CALL __MULW12
0005b2 01df      	MOVW R26,R30
0005b3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:23 WORDS
                 SUBOPT_0x3:
0005b4 e0f0      	LDI  R31,0
0005b5 0fea      	ADD  R30,R26
0005b6 1ffb      	ADC  R31,R27
0005b7 940e 06be 	CALL __CWD1
0005b9 940e 062f 	CALL __CDF1
0005bb 01df      	MOVW R26,R30
0005bc 01cb      	MOVW R24,R22
                +
0005bd eae4     +LDI R30 , LOW ( 0x414D70A4 )
0005be e7f0     +LDI R31 , HIGH ( 0x414D70A4 )
0005bf e46d     +LDI R22 , BYTE3 ( 0x414D70A4 )
0005c0 e471     +LDI R23 , BYTE4 ( 0x414D70A4 )
                 	__GETD1N 0x414D70A4
0005c1 940e 065d 	CALL __DIVF21
0005c3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4:
0005c4 940e 05f6 	CALL __CFD1U
0005c6 93ed      	ST   X+,R30
0005c7 93fc      	ST   X,R31
0005c8 9508      	RET
                 
                 
                 	.CSEG
                 __ROUND_REPACK:
0005c9 2355      	TST  R21
0005ca f442      	BRPL __REPACK
0005cb 3850      	CPI  R21,0x80
0005cc f411      	BRNE __ROUND_REPACK0
0005cd ffe0      	SBRS R30,0
0005ce c004      	RJMP __REPACK
                 __ROUND_REPACK0:
0005cf 9631      	ADIW R30,1
0005d0 1f69      	ADC  R22,R25
0005d1 1f79      	ADC  R23,R25
0005d2 f06b      	BRVS __REPACK1
                 
                 __REPACK:
0005d3 e850      	LDI  R21,0x80
0005d4 2757      	EOR  R21,R23
0005d5 f411      	BRNE __REPACK0
0005d6 935f      	PUSH R21
0005d7 c073      	RJMP __ZERORES
                 __REPACK0:
0005d8 3f5f      	CPI  R21,0xFF
0005d9 f031      	BREQ __REPACK1
0005da 0f66      	LSL  R22
0005db 0c00      	LSL  R0
0005dc 9557      	ROR  R21
0005dd 9567      	ROR  R22
0005de 2f75      	MOV  R23,R21
0005df 9508      	RET
                 __REPACK1:
0005e0 935f      	PUSH R21
0005e1 2000      	TST  R0
0005e2 f00a      	BRMI __REPACK2
0005e3 c073      	RJMP __MAXRES
                 __REPACK2:
0005e4 c06c      	RJMP __MINRES
                 
                 __UNPACK:
0005e5 e850      	LDI  R21,0x80
0005e6 2e19      	MOV  R1,R25
0005e7 2215      	AND  R1,R21
0005e8 0f88      	LSL  R24
0005e9 1f99      	ROL  R25
0005ea 2795      	EOR  R25,R21
0005eb 0f55      	LSL  R21
0005ec 9587      	ROR  R24
                 
                 __UNPACK1:
0005ed e850      	LDI  R21,0x80
0005ee 2e07      	MOV  R0,R23
0005ef 2205      	AND  R0,R21
0005f0 0f66      	LSL  R22
0005f1 1f77      	ROL  R23
0005f2 2775      	EOR  R23,R21
0005f3 0f55      	LSL  R21
0005f4 9567      	ROR  R22
0005f5 9508      	RET
                 
                 __CFD1U:
0005f6 9468      	SET
0005f7 c001      	RJMP __CFD1U0
                 __CFD1:
0005f8 94e8      	CLT
                 __CFD1U0:
0005f9 935f      	PUSH R21
0005fa dff2      	RCALL __UNPACK1
0005fb 3870      	CPI  R23,0x80
0005fc f018      	BRLO __CFD10
0005fd 3f7f      	CPI  R23,0xFF
0005fe f408      	BRCC __CFD10
0005ff c04b      	RJMP __ZERORES
                 __CFD10:
000600 e156      	LDI  R21,22
000601 1b57      	SUB  R21,R23
000602 f4aa      	BRPL __CFD11
000603 9551      	NEG  R21
000604 3058      	CPI  R21,8
000605 f40e      	BRTC __CFD19
000606 3059      	CPI  R21,9
                 __CFD19:
000607 f030      	BRLO __CFD17
000608 efef      	SER  R30
000609 efff      	SER  R31
00060a ef6f      	SER  R22
00060b e77f      	LDI  R23,0x7F
00060c f977      	BLD  R23,7
00060d c01a      	RJMP __CFD15
                 __CFD17:
00060e 2777      	CLR  R23
00060f 2355      	TST  R21
000610 f0b9      	BREQ __CFD15
                 __CFD18:
000611 0fee      	LSL  R30
000612 1fff      	ROL  R31
000613 1f66      	ROL  R22
000614 1f77      	ROL  R23
000615 955a      	DEC  R21
000616 f7d1      	BRNE __CFD18
000617 c010      	RJMP __CFD15
                 __CFD11:
000618 2777      	CLR  R23
                 __CFD12:
000619 3058      	CPI  R21,8
00061a f028      	BRLO __CFD13
00061b 2fef      	MOV  R30,R31
00061c 2ff6      	MOV  R31,R22
00061d 2f67      	MOV  R22,R23
00061e 5058      	SUBI R21,8
00061f cff9      	RJMP __CFD12
                 __CFD13:
000620 2355      	TST  R21
000621 f031      	BREQ __CFD15
                 __CFD14:
000622 9576      	LSR  R23
000623 9567      	ROR  R22
000624 95f7      	ROR  R31
000625 95e7      	ROR  R30
000626 955a      	DEC  R21
000627 f7d1      	BRNE __CFD14
                 __CFD15:
000628 2000      	TST  R0
000629 f40a      	BRPL __CFD16
00062a d07b      	RCALL __ANEGD1
                 __CFD16:
00062b 915f      	POP  R21
00062c 9508      	RET
                 
                 __CDF1U:
00062d 9468      	SET
00062e c001      	RJMP __CDF1U0
                 __CDF1:
00062f 94e8      	CLT
                 __CDF1U0:
000630 9730      	SBIW R30,0
000631 4060      	SBCI R22,0
000632 4070      	SBCI R23,0
000633 f0b1      	BREQ __CDF10
000634 2400      	CLR  R0
000635 f026      	BRTS __CDF11
000636 2377      	TST  R23
000637 f412      	BRPL __CDF11
000638 9400      	COM  R0
000639 d06c      	RCALL __ANEGD1
                 __CDF11:
00063a 2e17      	MOV  R1,R23
00063b e17e      	LDI  R23,30
00063c 2011      	TST  R1
                 __CDF12:
00063d f032      	BRMI __CDF13
00063e 957a      	DEC  R23
00063f 0fee      	LSL  R30
000640 1fff      	ROL  R31
000641 1f66      	ROL  R22
000642 1c11      	ROL  R1
000643 cff9      	RJMP __CDF12
                 __CDF13:
000644 2fef      	MOV  R30,R31
000645 2ff6      	MOV  R31,R22
000646 2d61      	MOV  R22,R1
000647 935f      	PUSH R21
000648 df8a      	RCALL __REPACK
000649 915f      	POP  R21
                 __CDF10:
00064a 9508      	RET
                 
                 __ZERORES:
00064b 27ee      	CLR  R30
00064c 27ff      	CLR  R31
00064d 2766      	CLR  R22
00064e 2777      	CLR  R23
00064f 915f      	POP  R21
000650 9508      	RET
                 
                 __MINRES:
000651 efef      	SER  R30
000652 efff      	SER  R31
000653 e76f      	LDI  R22,0x7F
000654 ef7f      	SER  R23
000655 915f      	POP  R21
000656 9508      	RET
                 
                 __MAXRES:
000657 efef      	SER  R30
000658 efff      	SER  R31
000659 e76f      	LDI  R22,0x7F
00065a e77f      	LDI  R23,0x7F
00065b 915f      	POP  R21
00065c 9508      	RET
                 
                 __DIVF21:
00065d 935f      	PUSH R21
00065e df86      	RCALL __UNPACK
00065f 3870      	CPI  R23,0x80
000660 f421      	BRNE __DIVF210
000661 2011      	TST  R1
                 __DIVF211:
000662 f40a      	BRPL __DIVF219
000663 cfed      	RJMP __MINRES
                 __DIVF219:
000664 cff2      	RJMP __MAXRES
                 __DIVF210:
000665 3890      	CPI  R25,0x80
000666 f409      	BRNE __DIVF218
                 __DIVF217:
000667 cfe3      	RJMP __ZERORES
                 __DIVF218:
000668 2401      	EOR  R0,R1
000669 9408      	SEC
00066a 0b97      	SBC  R25,R23
00066b f41b      	BRVC __DIVF216
00066c f3d4      	BRLT __DIVF217
00066d 2000      	TST  R0
00066e cff3      	RJMP __DIVF211
                 __DIVF216:
00066f 2f79      	MOV  R23,R25
000670 931f      	PUSH R17
000671 932f      	PUSH R18
000672 933f      	PUSH R19
000673 934f      	PUSH R20
000674 2411      	CLR  R1
000675 2711      	CLR  R17
000676 2722      	CLR  R18
000677 2733      	CLR  R19
000678 2744      	CLR  R20
000679 2755      	CLR  R21
00067a e290      	LDI  R25,32
                 __DIVF212:
00067b 17ae      	CP   R26,R30
00067c 07bf      	CPC  R27,R31
00067d 0786      	CPC  R24,R22
00067e 0741      	CPC  R20,R17
00067f f030      	BRLO __DIVF213
000680 1bae      	SUB  R26,R30
000681 0bbf      	SBC  R27,R31
000682 0b86      	SBC  R24,R22
000683 0b41      	SBC  R20,R17
000684 9408      	SEC
000685 c001      	RJMP __DIVF214
                 __DIVF213:
000686 9488      	CLC
                 __DIVF214:
000687 1f55      	ROL  R21
000688 1f22      	ROL  R18
000689 1f33      	ROL  R19
00068a 1c11      	ROL  R1
00068b 1faa      	ROL  R26
00068c 1fbb      	ROL  R27
00068d 1f88      	ROL  R24
00068e 1f44      	ROL  R20
00068f 959a      	DEC  R25
000690 f751      	BRNE __DIVF212
000691 01f9      	MOVW R30,R18
000692 2d61      	MOV  R22,R1
000693 914f      	POP  R20
000694 913f      	POP  R19
000695 912f      	POP  R18
000696 911f      	POP  R17
000697 2366      	TST  R22
000698 f032      	BRMI __DIVF215
000699 0f55      	LSL  R21
00069a 1fee      	ROL  R30
00069b 1fff      	ROL  R31
00069c 1f66      	ROL  R22
00069d 957a      	DEC  R23
00069e f243      	BRVS __DIVF217
                 __DIVF215:
00069f df29      	RCALL __ROUND_REPACK
0006a0 915f      	POP  R21
0006a1 9508      	RET
                 
                 __ANEGW1:
0006a2 95f1      	NEG  R31
0006a3 95e1      	NEG  R30
0006a4 40f0      	SBCI R31,0
0006a5 9508      	RET
                 
                 __ANEGD1:
0006a6 95f0      	COM  R31
0006a7 9560      	COM  R22
0006a8 9570      	COM  R23
0006a9 95e1      	NEG  R30
0006aa 4fff      	SBCI R31,-1
0006ab 4f6f      	SBCI R22,-1
0006ac 4f7f      	SBCI R23,-1
0006ad 9508      	RET
                 
                 __LSLW3:
0006ae 0fee      	LSL  R30
0006af 1fff      	ROL  R31
                 __LSLW2:
0006b0 0fee      	LSL  R30
0006b1 1fff      	ROL  R31
0006b2 0fee      	LSL  R30
0006b3 1fff      	ROL  R31
0006b4 9508      	RET
                 
                 __ASRW4:
0006b5 95f5      	ASR  R31
0006b6 95e7      	ROR  R30
                 __ASRW3:
0006b7 95f5      	ASR  R31
0006b8 95e7      	ROR  R30
                 __ASRW2:
0006b9 95f5      	ASR  R31
0006ba 95e7      	ROR  R30
0006bb 95f5      	ASR  R31
0006bc 95e7      	ROR  R30
0006bd 9508      	RET
                 
                 __CWD1:
0006be 2f6f      	MOV  R22,R31
0006bf 0f66      	ADD  R22,R22
0006c0 0b66      	SBC  R22,R22
0006c1 2f76      	MOV  R23,R22
0006c2 9508      	RET
                 
                 __MULW12U:
0006c3 9ffa      	MUL  R31,R26
0006c4 2df0      	MOV  R31,R0
0006c5 9feb      	MUL  R30,R27
0006c6 0df0      	ADD  R31,R0
0006c7 9fea      	MUL  R30,R26
0006c8 2de0      	MOV  R30,R0
0006c9 0df1      	ADD  R31,R1
0006ca 9508      	RET
                 
                 __MULW12:
0006cb d004      	RCALL __CHKSIGNW
0006cc dff6      	RCALL __MULW12U
0006cd f40e      	BRTC __MULW121
0006ce dfd3      	RCALL __ANEGW1
                 __MULW121:
0006cf 9508      	RET
                 
                 __CHKSIGNW:
0006d0 94e8      	CLT
0006d1 fff7      	SBRS R31,7
0006d2 c002      	RJMP __CHKSW1
0006d3 dfce      	RCALL __ANEGW1
0006d4 9468      	SET
                 __CHKSW1:
0006d5 ffb7      	SBRS R27,7
0006d6 c006      	RJMP __CHKSW2
0006d7 95a0      	COM  R26
0006d8 95b0      	COM  R27
0006d9 9611      	ADIW R26,1
0006da f800      	BLD  R0,0
0006db 9403      	INC  R0
0006dc fa00      	BST  R0,0
                 __CHKSW2:
0006dd 9508      	RET
                 
                 __SAVELOCR6:
0006de 935a      	ST   -Y,R21
                 __SAVELOCR5:
0006df 934a      	ST   -Y,R20
                 __SAVELOCR4:
0006e0 933a      	ST   -Y,R19
                 __SAVELOCR3:
0006e1 932a      	ST   -Y,R18
                 __SAVELOCR2:
0006e2 931a      	ST   -Y,R17
0006e3 930a      	ST   -Y,R16
0006e4 9508      	RET
                 
                 __LOADLOCR6:
0006e5 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
0006e6 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
0006e7 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
0006e8 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
0006e9 8119      	LDD  R17,Y+1
0006ea 8108      	LD   R16,Y
0006eb 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATxmega64A3U register use summary:
r0 :  30 r1 :  12 r2 :   0 r3 :   0 r4 :   3 r5 :   2 r6 :   4 r7 :   3 
r8 :   9 r9 :   5 r10:   6 r11:   5 r12:   3 r13:   1 r14:   0 r15:   0 
r16:  20 r17:  28 r18:  19 r19:  14 r20:  20 r21:  48 r22:  32 r23:  32 
r24:  10 r25:  11 r26:  90 r27:  28 r28:  16 r29:   1 r30: 581 r31:  83 
x  :  15 y  :  77 z  :  15 
Registers used: 31 out of 35 (88.6%)

ATxmega64A3U instruction use summary:
.lds  :   0 .lds.l:   0 .sts  :   0 .sts.l:   0 adc   :   7 add   :   8 
adiw  :  18 and   :   5 andi  :  41 asr   :   4 bclr  :   0 bld   :   2 
brbc  :   0 brbs  :   0 brcc  :   1 brcs  :   0 break :   0 breq  :  18 
brge  :   2 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :   4 
brlt  :   1 brmi  :   3 brne  :  20 brpl  :   5 brsh  :   1 brtc  :   2 
brts  :   1 brvc  :   1 brvs  :   2 bset  :   0 bst   :   1 call  :  26 
cbi   :   0 cbr   :   0 clc   :   1 clh   :   0 cli   :   5 cln   :   0 
clr   :  25 cls   :   0 clt   :   3 clv   :   0 clz   :   0 com   :   6 
cp    :   8 cpc   :   9 cpi   :  18 cpse  :   0 dec   :   6 des   :   0 
elpm  :   0 eor   :   4 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 
ijmp  :   0 in    :   4 inc   :   1 jmp   : 128 ld    :  21 ldd   :  26 
ldi   : 172 lds   :  64 lpm   :   2 lsl   :  13 lsr   :   1 mov   :  38 
movw  :  38 mul   :   3 muls  :   2 mulsu :   0 neg   :   4 nop   :   0 
or    :   5 ori   :  11 out   :  27 pop   :  10 push  :   9 rcall :  35 
ret   :  34 reti  :   2 rjmp  :  42 rol   :  23 ror   :  11 sbc   :   5 
sbci  :  10 sbi   :   0 sbic  :   0 sbis  :   0 sbiw  :   6 sbr   :   0 
sbrc  :   0 sbrs  :   3 sec   :   2 seh   :   0 sei   :   2 sen   :   0 
ser   :   8 ses   :   0 set   :   3 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :  46 std   :  13 sts   : 219 sub   :   2 subi  :  11 
swap  :   3 tst   :  10 wdr   :   0 
Instructions used: 73 out of 117 (62.4%)

ATxmega64A3U memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000dd8   3526     18   3544   69632   5.1%
[.dseg] 0x002000 0x002493      0    147    147    4096   3.6%
[.eseg] 0x000000 0x000000      0      0      0    2048   0.0%

Assembly complete, 0 errors, 12 warnings
